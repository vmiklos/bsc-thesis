\section{Megvalósítás}

A megvalósítás során a tervezés folyamán elemzett használati eseteket
fogjuk sorra implementálni. Terjedelmi okokból nem valósítjuk meg
a teljes funkcionalitást, így célszerû mindjárt az elején definiálni,
hogy mely részletek esetén alkalmazunk egyszerûsítéseket, és hol cél a
teljes megvalósítás.

A tervezés során definiált osztályok, az párhuzamosság, hibatûrés és
elosztottság támogatása a program részét képezik. Az elkészítés során
nyomon fogjuk követni, ahogy a tervezés szakaszában leírt használati
esetek sorra mûködõképessé válnak.

Amit nem vagy csak egyszerûsítve valósítunk meg:

\begin{itemize}
\item A szenzorok nem automatikusan fedezik fel a központokat, hanem egy
konfigurációs állomány elõre definiálja ezek listáját.
\item A korábban felvetett biztonsági kérdésekkel nem foglalkozunk,
feltételezzük, hogy a rendszer zárt, a rendszer elemei pedig
megbízhatóak.
\item Eltekintünk a grafikus felhasználói felület létrehozásától,
egyszerû parancssoros interfészt adunk a felhasználónak.
\end{itemize}

\subsection{Elsõ, már mûködõ változat}

A legkisebb mûködõ változata a rendszernek az az eset, mikor a
rendszerben egy szenzor, egy központ és egy terminál van. Mivel ez lesz
minden késõbbi változat alapja, tekintsük át tüzetesen a mûködését. A
késõbbiekben csak az ehhez a változathoz képest eszközölt módosításokat
ismertetjük.

E változat mûködése során a felhasználó egy központot indít, majd egy
terminált, mely regisztrál a központba, végül egy szenzort, mely indulás
után azonnal értesítést küld. Ezt az értesítést kapja meg a központ, majd
továbbítja a terminálnak.

\subsubsection*{Központ}

A központ három olyan függvényt definiál, mely a processz életciklusát
érinti:

\begin{lstlisting}
start() -> register(center, spawn(fun() -> put(sensors, []), put(subscriptions, []), loop() end)).

stop() -> center ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

A \texttt{start/0} függvény egy új processzt indít az aktuális csomóponton, mely
inicializálja a szenzorok és feliratkozások listáját, majd várakozó
állapotba kerül, ld. késõbb.

A \texttt{stop/0} függvény ennek az új processznek küld egy üzenetet, melynek hatására az leáll.

A \texttt{ping/0} függvény kizárólag hibakeresési célokat szolgál a lejjebb
ismertetésre kerülõ \texttt{rpc/1} függvény felhasználásával, lehetõvé téve, hogy
megvizsgáljuk, hogy a központ válaszképes-e.

További négy függvény pedig a központ tényleges vezérlésére szolgál:

\begin{lstlisting}
reg(Address, Name) -> rpc({reg, Address, Name}).

lookup(Name) -> rpc({lookup, Name}).

subscribe(Name, Address) -> rpc({subscribe, Name, Address}).

notify(Message) -> rpc({notify, Message}).
\end{lstlisting}

Láthatjuk, hogy ezek mind a lenn ismertetett \texttt{rpc/1} függvény köré épített
csomagoló függvények.

A csomagoló függvények által hívott \texttt{rpc/1} függvény a következõ:

\begin{lstlisting}
rpc(Q) ->
 center ! {self(), Q},
 receive
  {center, Reply} ->
   Reply
 end.
\end{lstlisting}

A függvény a korábban center néven regisztrált
\footnote{Regisztráción és regisztráció törlésén itt az Erlang
rendszer \texttt{register/2} és \texttt{unregister/1} függvényeit értjük, ami lehetõséget
ad arra, hogy az aktuális csomóponton Pid-ekhez atomokat rendeljünk.
Ezek a regisztrációk más csomópontokról nem láthatóak, a teljes rendszer
szintjén nem egyediek, és ezt ki is fogjuk használni.}
processznek küld egy két
elemû ennest, megküldve a saját címét, valamint a tényleges adatokat,
majd a válaszként kapott értékkel tér vissza.

Végül a center néven regisztrált processzünk fõ függvénye a következõ:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {center, pong},
   loop();
  {From, {reg, Address, Name}} ->
   io:format("[~p] reg(~p,~p)~n", [node(), Address, Name]),
   Sensors = get(sensors),
   put(sensors, [{Address, Name}| Sensors]),
   From ! {center, ok},
   loop();
  {From, {lookup, Name}} ->
   io:format("[~p] lookup(~p)~n", [node(), Name]),
   Sensors = get(sensors),
   A = [A || {A, N} <- Sensors, N =:= Name],
   From ! {center, {ok,A}},
   loop();
  {From, {subscribe, Name, Address}} ->
   io:format("[~p] subscribe(~p,~p)~n", [node(), Name, Address]),
   Subscriptions = get(subscriptions),
   put(subscriptions, [{Name, Address}| Subscriptions]),
   From ! {center, ok},
   loop();
  {From, {notify, Message}} ->
   io:format("[~p] notify(~p)~n", [node(), Message]),
   {Data, Description, Fro, To, _Receiver} = Message,
   lists:foreach(fun(I) -> rpc:call(I, terminal, notify, [{Data, Description, Fro, To, node()}]) end,
    [A || {N, A} <- get(subscriptions), N =:= To]),
   From ! {center, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

Az egyes beérkezõ üzenetekre tehát a következõ válaszokat adja:

\begin{itemize}
\item A ping atomra mindig pong atommal válaszol.
\item A reg atomra a paraméterként kapott szenzor címét és nevét
regisztrálja a egy listába, melyet a process dictionary-ben tárol (mely az Erlang futtatórendszer része), így
késõbb is lehetõvé válik a módosítása.
\item A lookup atomra a paraméterként kapott névhez tartozó szenzor
címet adja vissza a sensors listából.
\item A subscribe atomra a paraméterként kapott névhez eltárolja a kapott címet.
\item A notify atom esetén egy öt elemû ennest (melynek elemeit a
tervezés során Message néven definiáltuk) vár paraméterként. Ebben
szerepel az, hogy milyen névre szól az üzenet. A központ azoknak a
termináloknak továbbítja az üzenetet, amelyek ilyen névvel iratkoztak
fel, beleírva saját magát mint továbbítót.
\item Végül a stop atomra leállítja az aktuális Erlang csomópontot.
\end{itemize}

A másik két elemmel ellentétben itt megfigyelhetõ, hogy a központnak
nincs konfigurációs állománya, valamint elindítása után nincs semmilyen
bekövetkezõ esemény.

\subsubsection*{Terminál}

A struktúra diagramban láthattuk, hogy a Center és a Terminal is egy
Node, így itt is megtalálható a processz életciklusával
kapcsolatos három függvény:

\begin{lstlisting}
start(ConfigFile) ->
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) -> rpc:call(C, center, subscribe, [E, node()]) end, Centers),
 register(terminal, spawn(fun() -> loop() end)).

stop() -> terminal ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

A \texttt{start/1} függvény azonban itt egy konfigurációs állományt vár paraméterül. Erre egy példa:

\begin{lstlisting}
{center, center0@clevo.local, event}.
\end{lstlisting}

A konfigurációs állomány szintaxisára az egyetlen megkötés az, hogy
minden egyes sorban egy Erlang termnek kell lennie, mivel ezt fogadja el
a \texttt{file:consult/1} értelmezõ függvény. A fenti file-ban az egyetlen sor egy
központra való feliratkozást definiál, erre utal a center atom. Az ennes
másik két paramétere a központ címét
\footnote{
A következõ, tesztelésrõl is szóló fejezetben látni fogjuk, hogy mi az
oka annak, hogy a cím ebben a formátumban lett megadva. Általánosságban
a cím egy csomópontot és egy gépet azonosító atomból áll, a kukac
karakterrel összekötve.
}
és annak az eseménynek a nevét
definiálja, melyre fel szeretnénk iratkozni az adott központban.

Az indítás során tehát értelmezzük a beállításokat, és a kérésnek
megfelelõen feliratkozunk a központoknál, azok subscribe metódusát
meghívva. Ha ez megtörtént, üzenetre várunk a lenn ismertetésre kerülõ
\texttt{loop/0} függvény használatával.

A \texttt{stop/0} és \texttt{ping/0} feladata és mûködése más ismerõs, a center modulban
definiáltakkal megegyezõ.

A terminálnak egyetlen, a modellben is létezõ metódusa a \texttt{notify/1}:

\begin{lstlisting}
notify(Message) -> rpc({notify, Message}).
\end{lstlisting}

A \texttt{center:notify/1}-hez hasonló módon ez is csak csomagoló függvény az
\texttt{rpc/1} köré.

A terminal modul maradék része a korábban hivatkozott \texttt{rpc/1} és \texttt{loop/0}
függvényekbõl áll:

\begin{lstlisting}
rpc(Q) ->
 terminal ! {self(), Q},
 receive
  {terminal, Reply} ->
   Reply
 end.

loop() ->
 receive
  {From, {ping}} ->
   From ! {terminal, pong},
   loop();
  {From, {notify, Message}} ->
   io:format("[~p] notify(~p)~n", [node(), Message]),
   From ! {terminal, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

Az \texttt{rpc/1} feladata tehát kommunikálni a terminal néven regisztrált
processzel: az üzenetküldés után válaszra várni, majd azzal
visszatérni. A center modulhoz hasonló módon itt is azért van erre
szükség erre a csomagolásra, mivel terminal néven más csomóponton más
processzt érhetünk el.

A \texttt{loop/0} függvény pedig üzeneteket vár:

\begin{itemize}
\item A ping és stop atomok az életciklus monitorozására és vezérlésére
szolgálnak a center modullal megegyezõ módon.
\item A notify atomra pedig a terminál egyszerûen a standard kimenetre
küldi a kapott üzenet tartalmát, nem túl felhasználóbarát módon.
\end{itemize}

\subsubsection*{Szenzor}

A sensor modul implementációja a start, stop és ping metódusokra:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E]),
  Message = {Data, desc, node(), E, false},
  rpc:call(C, center, notify, [Message])
 end, Centers),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)).

stop() -> sensor ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

Láthatjuk, hogy a start függvény itt is használ egy konfigurációs
állományt, melynek azonos a formátuma a szenzoréval. A feladata
természetesen más: itt azt adja meg, hogy melyik központnak milyen néven
kell elküldeni a mérési adatainkat.

Az elsõ változat tehát rögtön indulás után küld egy üzenetet a
konfigurációs állományban megadott központba, a megadott eseménynevet
használva, mely arról fogja informálni a terminálokat, hogy a desc
típusú mérési adat értéke data.

A tervezés során a szenzorok explicit lekérdezésének igénye is
felmerült, az ehhez szükséges függvények:

\begin{lstlisting}
query_data(Message) -> rpc({query_data, Message}).

control(Message) -> rpc({control, Message}).

rpc(Q) ->
 sensor ! {self(), Q},
 receive
  {sensor, Reply} ->
   Reply
 end.
\end{lstlisting}

Az elõzõekben megszokott módon ezek is az \texttt{rpc/1} függvényt hívják,
melynek mûködési elve nem változott a korábbi két modulhoz képest.

A korábban hivatkozott \texttt{loop/0} függvény pedig a következõ:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {sensor, pong},
   loop();
  {From, {query_data, {_Data, _Desc, Fro, _To, _Recv}}} ->
   rpc:call(Fro, terminal, notify, [{get(desc), desc, node(), Fro, false}]),
   From ! {sensor, ok},
   loop();
  {From, {control, {Data, _Desc, _Fro, _To, _Recv}}} ->
   put(desc, Data),
   From ! {sensor, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

\begin{itemize}
\item A ping és stop atomok kezelését már ismerjük
\item A query\_data atom hatására a szenzor process dictionary-jébõl lehet lekérdezni.
\item A control atom segítségével pedig vezérelni lehet a szenzort.
\end{itemize}

\subsection{Redundáns mûködés}

A redundáns mûködés két szempontból különbözik az elõzõ alfejezetben
ismertetett változattól:

\begin{itemize}
\item A rendszer indításakor mindhárom elembõl két-két példányt kell indítani.
\item A terminálok és szenzorok konfigurációs állományában két-két
központot kell definiálni.
\end{itemize}

Ez utóbbit például a következõképpen tehetjük meg:

\begin{lstlisting}
{center, center0@clevo.local, event}.
{center, center1@clevo.local, event}.
\end{lstlisting}

\subsection{Eszközmeghajtók támogatása}

Meghajtóprogramokra akkor van szükségünk, ha egy általános interfészen
keresztül akarunk elérni egy-egy eszközt, melynek a speciális jellemzõit
nem ismerjük. Tegyük fel, hogy egy szenzor többféle mérést is képes végezni,
és ezeket számozzuk.  A megvalósított példa esetén a szenzor egy
\texttt{querydesc/0} függvénnyel rendelkezik, a terminál ezt szeretné explicit
módon lekérdezni, de csak annyit tud, hogy ez a nulladik típusú mérési
funkciója az eszköznek. A driver modul fog abban segíteni, hogy a 0
alapján megkapja a querydesc atomot.

A modul egyetlen \texttt{translate/2} függvényt definiál az interfészében:

\begin{lstlisting}
sub(Str,Old,New) ->
       RegExp = "\\Q"++Old++"\\E",
       re:replace(Str,RegExp,New,[multiline, {return, list}]).

translate(Node, Num) ->
       Module = sub(sub(atom_to_list(Node), "@", "_"), ".", "_"),
       compile:file(Module),
       Modulea = list_to_atom(Module),
       list_to_atom(Modulea:translate(Num)).
\end{lstlisting}

Az elsõ segédfüggvény csomópont nevébõl a modul nevét állítja elõ,
kukacokat és pontokat aláhúzásjellel helyettesítve. A második pedig az
elõállított modulnév alapján lefordítja az eszközmeghajtót, meghívja annak
translate metódusát, és a kapott értékkel visszatér.

A sensor0\_clevo\_local modul egyetlen \texttt{translate/1} függvényt definiál:

\begin{lstlisting}
translate(Num) ->
       case Num of
        0 ->
         "querydesc";
        _ ->
         false
       end.
\end{lstlisting}

Ahhoz, hogy ezt ki is próbálhassuk, a szenzor kódjában a querydesc
függvényt implementálni kell:

\begin{lstlisting}
querydesc() -> rpc({querydesc}).
\end{lstlisting}

Valamint a \texttt{loop/0} függvényben egy új esetet kell felvenni:

\begin{lstlisting}
        {From, {querydesc}} ->
         From ! {sensor, get(desc)},
         loop();
\end{lstlisting}

\subsection{Felhasználói felület}

Idáig alapvetõen azzal foglalkoztunk, hogy hogyan tudunk adatokat küldeni Erlang csomópontok között.

A felhasználói felület feladata, hogy az idáig elkészült köztes réteget
felhasználva a felhasználók számára is hasznos támogatást nyújtson,
ezáltal tényleges életvitelt segítõ rendszert megvalósítva.

Felhasználói felületünk kialakítását kezdjük a szenzorral. A \texttt{start/1}
függvény idáig visszatért, ha sikeres volt az üzeneteket kezelõ process
regisztrációja terminal néven. Most ezt megváltoztatjuk, és
interaktívan, a standard bemenetrõl fogunk beolvasni értékeket, majd
azonnal jelzünk, ha a felhasználó ENTER-t ütött.

Ehhez a szenzor kódjában a \texttt{start/1} függvényt változtatjuk meg:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E])
 end, Centers),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)),
 io:format("Adja meg a mert adatot 'tipus szam' formaban, majd usson ENTER-t!\n"),
 io:format("A testhomerseklet merese utan peldaul 'h 38.2'\n"),
 read_stdin(Centers).
\end{lstlisting}

Az újonnan bevezetett read\_stdin függvény pedig:

\begin{lstlisting}
read_stdin(Centers) ->
 L = io:get_line("> "),
 [A|[B]] = re:split(L, " "),
 Desc = list_to_atom(binary_to_list(A)),
 {Data, _} = string:to_float(binary_to_list(B)),
 lists:foreach(fun({C, E}) ->
  Message = {Data, Desc, node(), E, false},
  rpc:call(C, center, notify, [Message])
 end, Centers),
 read_stdin(Centers).
\end{lstlisting}

A feladat második fele a terminál átalakítása; azt szeretnénk,
hogyha a hõmérséklet értéke meghaladja a 37.2 fokot, akkor csipogjon,
egyéb esetben pedig egyszerûen adjon barátságos kimenetet.

Ehhez a terminal modul \texttt{loop/0} függvényét a következõképpen módosítjuk:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {terminal, pong},
   loop();
  {From, {notify, Message}} ->
   {Data, Desc, _Fro, _To, _Recv} = Message,
   case Desc of
    h ->
     case Data > 37.2 of
      true ->
       io:fwrite([7]),
       io:format("Figyelem, a homerseklet ~p homerseklet tobb a megengedettnel!~n", [Data]);
      _ ->
       io:format("Uj homerseklet adat: ~p.~n", [Data])
      end;
    _ ->
     io:format("A '~p' uj erteke: ~p.~n", [Desc, Data])
   end,
   From ! {terminal, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

\subsection{Hibatûrés}

A rendszerrel szemben elvárás, hogy hibatûrõ legyen, azonban ezt idáig
nem valósítottuk meg, például ha hõmérsékletnek nem lebegõpontos számot
adunk meg, akkor nem kapunk semmilyen hibát, egyszerûen hibás lesz a
mûködés.

Két feladatunk van tehát:

\begin{itemize}
\item Hiba esetén biztosítani, hogy leálljon az adott processz, mielõtt
az hibás mûködéshez vezetne.
\item A leállt processz helyébe újat indítani.
\end{itemize}

A leállás biztosításához a \texttt{terminal:read\_stdin/0} függvényt a következõképpen
módosíthatjuk:

\begin{lstlisting}
read_stdin(Centers) ->
 L = io:get_line("> "),
 [A|[B]] = re:split(L, " "),
 Desc = list_to_atom(binary_to_list(A)),
 {Data, _} = string:to_float(binary_to_list(B)),
 case Data of
  error ->
   erlang:error(badarg);
  _ ->
   lists:foreach(fun({C, E}) ->
      Message = {Data, Desc, node(), E, false},
      rpc:call(C, center, notify, [Message])
    end, Centers),
   read_stdin(Centers)
 end.
\end{lstlisting}

Az új processz indítása két lépéses folyamat. Elõször is definiálni kell
egy függvényt, mely akkor hívódik meg, ha az aktuális processz leáll:

\begin{lstlisting}
on_exit(Pid, Fun) ->
 spawn(fun() ->
  process_flag(trap_exit, true),
  link(Pid),
  receive
   {'EXIT', Pid, _Why} ->
    Fun()
  end
 end).
\end{lstlisting}

Valamint a \texttt{start/1} függvényben ezt a függvényt regisztrálnunk kell:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E])
 end, Centers),
 catch unregister(sensor),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)),
 on_exit(self(),
  fun() ->
    io:format("A szenzor hibaval lepett ki, ujrainditas...~n"),
    start(ConfigFile)
  end),
 io:format("Adja meg a mert adatot 'tipus szam' formaban, majd usson ENTER-t!\n"),
 io:format("A testhomerseklet merese utan peldaul 'h 38.2'\n"),
 read_stdin(Centers).
\end{lstlisting}
