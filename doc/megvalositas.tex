\section{Megvalósítás}

A megvalósítás során a tervezés folyamán felmerült használati eseteket
fogjuk sorra implementálni. Terjedelmi okokból nem kerül megvalósításra
a teljes funkcionalitás, így célszerû mindjárt az elején definiálni,
hogy mely részletek esetén alkalmazunk egyszerûsítéseket, és hol cél a
teljes megvalósítás.

A tervezés során definiált osztályok, az párhuzamosság, hibatûrés és
elosztottság támogatása a program részét képezik. Az elkészítés során
nyomon fogjuk követni, ahogy a tervezés szakaszában leírt használati
esetek sorra mûködõképessé válnak.

Ami nem kerül teljes megvalósításra:

\begin{itemize}
\item A szenzorok nem automatikusan fedezik fel a központokat, hanem egy
konfigurációs állomány elõre definiálja ezek listáját.
\item A korábban felvetett biztonsági kérdésekkel nem foglalkozunk,
feltételezzük, hogy a rendszer zárt, a rendszer elemei pedig
megbízhatóak.
\item Eltekintünk a grafikus felhasználói felület létrehozásától,
egyszerû parancssoros interfészt biztosítva a felhasználó számára.
\end{itemize}

\subsection{Elsõ, már mûködõ változat}

A legkisebb már mûködõ változata a rendszernek az az eset, mikor a
rendszerben egy szenzor, egy központ és egy terminál van. Mivel ez lesz
minden késõbbi változat alapja, tekintsük át tüzetesen a mûködését. A
késõbbiekben csak az ehhez a változathoz képest eszközölt módosítások
kerülnek ismertetésre.

E változat mûködése során a felhasználó egy központot indít, majd egy
terminált, mely regisztrál a központba, végül egy szenzort, mely indulás
után azonnal értesít. Ezt az értesítést kapja meg a központ, majd
továbbítja a terminálnak.

\subsubsection*{Központ}

A központ három olyan függvényt definiál, mely a process életciklusát
érinti:

\begin{lstlisting}
start() -> register(center, spawn(fun() -> put(sensors, []), put(subscriptions, []), loop() end)).

stop() -> center ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

A start/0 függvény egy új processt indít az aktuális node-on, mely
inicializálja a szenzorok és feliratkozások listáját, majd várakozó
állapotba kerül, ld. késõbb.

A stop/0 függvény ennek az új processnek küld egy üzenetet, melynek hatására az leáll.

A ping/0 függvény kizárólag hibakeresési célokat szolgál a lejjebb
ismertetésre kerülõ rpc/1 függvény felhasználásával, lehetõvé téve, hogy
megvizsgáljuk, hogy a központ válaszképes-e.

További négy függvény pedig a központ tényleges vezérlésére szolgál:

\begin{lstlisting}
reg(Address, Name) -> rpc({reg, Address, Name}).

lookup(Name) -> rpc({lookup, Name}).

subscribe(Name, Address) -> rpc({subscribe, Name, Address}).

notify(Message) -> rpc({notify, Message}).
\end{lstlisting}

Láthatjuk, hogy ezek mind a lenn ismertetett rpc/1 függvény köré épített
csomagoló függvények.

A csomagoló függvények által hívott rpc/1 függvény a következõ:

\begin{lstlisting}
rpc(Q) ->
 center ! {self(), Q},
 receive
  {center, Reply} ->
   Reply
 end.
\end{lstlisting}

A függvény a korábban center néven regisztrált
\footnote{Regisztráció és regisztráció törlése alatt itt az Erlang
rendszer register/2 és unregister/1 függvényeit értjük, mely lehetõséget
biztosít arra, hogy az aktuális node-on Pid-ekhez atomokat rendeljünk.
Ezek a regisztrációk más node-okról nem láthatóak, a teljes rendszer
szintjén nem egyediek, és ezt ki is fogjuk használni.}
processnek küld egy két
elemû ennest, megküldve a saját címét, valamint a tényleges adatokat,
majd a válaszként kapott értékkel tér vissza.

Végül a center néven regisztrált processünk fõ függvénye a következõ:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {center, pong},
   loop();
  {From, {reg, Address, Name}} ->
   io:format("[~p] reg(~p,~p)~n", [node(), Address, Name]),
   Sensors = get(sensors),
   put(sensors, [{Address, Name}| Sensors]),
   From ! {center, ok},
   loop();
  {From, {lookup, Name}} ->
   io:format("[~p] lookup(~p)~n", [node(), Name]),
   Sensors = get(sensors),
   A = [A || {A, N} <- Sensors, N =:= Name],
   From ! {center, {ok,A}},
   loop();
  {From, {subscribe, Name, Address}} ->
   io:format("[~p] subscribe(~p,~p)~n", [node(), Name, Address]),
   Subscriptions = get(subscriptions),
   put(subscriptions, [{Name, Address}| Subscriptions]),
   From ! {center, ok},
   loop();
  {From, {notify, Message}} ->
   io:format("[~p] notify(~p)~n", [node(), Message]),
   {Data, Description, Fro, To, _Receiver} = Message,
   lists:foreach(fun(I) -> rpc:call(I, terminal, notify, [{Data, Description, Fro, To, node()}]) end,
    [A || {N, A} <- get(subscriptions), N =:= To]),
   From ! {center, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

Az egyes beérkezõ üzenetekre tehát a következõ válaszokat adja:

\begin{itemize}
\item A ping atomra mindig pong atommal válaszol.
\item A reg atomra a paraméterként kapott szenzor címét és nevét
regisztrálja a egy listába, melyet a process dictionary-ben tárol, így
késõbb is lehetõvé válik annak módosítása.
\item A lookup atomra a paraméterként kapott névhez tartozó szenzor
címet adja vissza vissza a sensors listából.
\item A subscribe atomra a paraméterként kapott névhez eltárolja a kapott címet.
\item A notify atom esetén egy öt elemû ennest (melynek elemeit a
tervezés során Message néven definiáltuk) vár paraméterként. Ebben
szerepel az, hogy milyen névre szól az üzenet. A központ azoknak a
termináloknak továbbítja az üzenetet, amelyek ilyen névvel iratkoztak
fel, beleírva saját magát, mint továbbító.
\item Végül a stop atomra leállítja az aktuális Erlang node-ot.
\end{itemize}

A másik két elemmel ellentétben itt megfigyelhetõ, hogy a központnak
nincs konfigurációs állománya, valamint elindítása után nincs semmilyen
bekövetkezõ esemény.

\subsubsection*{Terminál}

A struktúra diagramban láthattuk, hogy a Center és a Terminal is egy
Node, így itt is megtalálható a három, a process életciklusával
kapcsolatos függvény:

\begin{lstlisting}
start(ConfigFile) ->
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) -> rpc:call(C, center, subscribe, [E, node()]) end, Centers),
 register(terminal, spawn(fun() -> loop() end)).

stop() -> terminal ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

A start/1 függvény azonban itt egy konfigurációs állományt vár paraméterül. Erre egy példa:

\begin{lstlisting}
{center, center0@clevo.local, event}.
\end{lstlisting}

A konfigurációs állomány szintaxisára az egyetlen megkötés az, hogy
minden egyes sorban egy Erlang termnek kell lennie, mivel ezt fogadja el
a file:consult/1 értelmezõ függvény. A fenti file-ban az egyetlen sor egy
központra való feliratkozást definiál, erre utal a center atom. Az ennes
másik két paramétere a központ címét
\footnote{
A következõ, tesztelésrõl is szóló fejezetben látni fogjuk, hogy mi az
oka annak, hogy a cím ebben a formátumban lett megadva. Általánosságban
a cím egy node-ot és egy gépet azonosító atomból áll, a kukac
karakterrel összekötve.
}
és annak az eseménynek a nevét
definiálja, melyre fel szeretnénk iratkozni az adott központban.

Az indítás során tehát értelmezzük a beállításokat, és a kérésnek
megfelelõen feliratkozunk a központoknál, azok subscribe metódusát
meghívva. Ha ez megtörtént, üzenetre várunk a lenn ismertetésre kerülõ
loop/0 függvény használatával.

A stop/0 és ping/0 feladata és mûködése más ismerõs, a center modulban
definiáltakkal megegyezõ.

A terminálnak egyetlen, a modellben is létezõ metódusa a notify/1:

\begin{lstlisting}
notify(Message) -> rpc({notify, Message}).
\end{lstlisting}

A center:notify/1-hez hasonló módon ez is csak csomagoló függvény az
rpc/1 köré.

A terminal modul maradék része a korábban hivatkozott rpc/1 és loop/0
függvényekbõl áll:

\begin{lstlisting}
rpc(Q) ->
 terminal ! {self(), Q},
 receive
  {terminal, Reply} ->
   Reply
 end.

loop() ->
 receive
  {From, {ping}} ->
   From ! {terminal, pong},
   loop();
  {From, {notify, Message}} ->
   io:format("[~p] notify(~p)~n", [node(), Message]),
   From ! {terminal, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

Az rpc/1 feladata tehát kommunikálni a terminal néven regisztrált
process-szel: az üzenetküldés után válaszra várni, majd azzal
visszatérni. A center modulhoz hasonló módon itt is azért van erre
szükség erre a csomagolásra, mivel terminal néven más node-on más
processt érhetünk el.

A loop/0 függvény pedig üzeneteket vár:

\begin{itemize}
\item A ping és stop atomok az életciklus monitorozására és vezérlésére
szolgálnak a center modullal megegyezõ módon.
\item A notify atomra pedig a terminál egyszerûen a standard kimenetre
küldi a kapott üzenet tartalmát, nem túl felhasználóbarát módon.
\end{itemize}

\subsubsection*{Szenzor}

A sensor modul implementációja a start, stop és ping metódusokra:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E]),
  Message = {Data, desc, node(), E, false},
  rpc:call(C, center, notify, [Message])
 end, Centers),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)).

stop() -> sensor ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

Láthatjuk, hogy a start függvény itt is használ egy konfigurációs
állományt, melynek azonos a formátuma a szenzoréval. A feladata
természetesen más: itt azt adja meg, hogy melyik központnak milyen néven
kell elküldeni a mérési adatainkat.

Az elsõ változat tehát rögtön indulás után küld egy üzenetet a
konfigurációs állományban megadott központba, a megadott eseménynevet
használva, mely arról fogja informálni a terminálokat, hogy a desc
típusú mérési adat értéke data.

A tervezés során a szenzorok explicit lekérdezésének igénye is
felmerült, az ehhez szükséges függvények:

\begin{lstlisting}
query_data(Message) -> rpc({query_data, Message}).

control(Message) -> rpc({control, Message}).

rpc(Q) ->
 sensor ! {self(), Q},
 receive
  {sensor, Reply} ->
   Reply
 end.
\end{lstlisting}

Az elõzõekben megszokott módon ezek is az rpc/1 függvényt hívják,
melynek mûködési elve nem változott a korábbi két modulhoz képest.

A korábban hivatkozott loop/0 függvénye pedig a következõ:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {sensor, pong},
   loop();
  {From, {query_data, {_Data, _Desc, Fro, _To, _Recv}}} ->
   rpc:call(Fro, terminal, notify, [{get(desc), desc, node(), Fro, false}]),
   From ! {sensor, ok},
   loop();
  {From, {control, {Data, _Desc, _Fro, _To, _Recv}}} ->
   put(desc, Data),
   From ! {sensor, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

\begin{itemize}
\item A ping és stop atomok kezelését már ismerjük
\item A query\_data atom hatására a szenzor process dictionary-jébõl lehet lekérdezni.
\item A control atom segítségével pedig vezérelni lehet a szenzort.
\end{itemize}

\subsection{Redundáns mûködés}

A redundáns mûködés két szempontból különbözik az elõzõ alfejezetben
ismertetett változathoz képest:

\begin{itemize}
\item A rendszer indításakor mindhárom elembõl két példányt kell indítani.
\item A terminálok és szenzorok konfigurációs állományába két-két
központot kell definiálni.
\end{itemize}

Ez utóbbit például a következõképpen tehetjük meg:

\begin{lstlisting}
{center, center0@clevo.local, event}.
{center, center1@clevo.local, event}.
\end{lstlisting}

\subsection{Meghajtóprogramok támogatása}

Meghajtóprogramokra akkor van szükségünk, ha egy általános interfészen
keresztül akarunk elérni egy-egy eszközt, melynek a speciális jellemzõit
nem ismerjük. Tegyük fel, hogy egy szenzor több mérést is képes végezni,
és ezeket számozzuk.  A megvalósított példa esetén a szenzor egy
querydesc/0 függvénnyel rendelkezik, a terminál ezt szeretné explicit
módon lekérdezni, de csak annyit tud, hogy ez a nulladik típusú mérési
funkciója az eszköznek. A driver modul fog abban segíteni, hogy a 0
alapján megkapja a querydesc atomot.

A modul egyetlen translate/2 függvényt definiál az interfészében:

\begin{lstlisting}
sub(Str,Old,New) ->
       RegExp = "\\Q"++Old++"\\E",
       re:replace(Str,RegExp,New,[multiline, {return, list}]).

translate(Node, Num) ->
       Module = sub(sub(atom_to_list(Node), "@", "_"), ".", "_"),
       compile:file(Module),
       Modulea = list_to_atom(Module),
       list_to_atom(Modulea:translate(Num)).
\end{lstlisting}

Az elsõ segédfüggvény node nevébõl a driver modul nevét állítja elõ, A
kukacokat és pontokat aláhúzásjellel helyettesítve. A második pedig az
elõállított modulnév alapján lefordítja a drivert, meghívja annak
translate metódusát, és a kapott értékkel visszatér.

A sensor0\_clevo\_local modul egyetlen translate/1 függvényt definiál:

\begin{lstlisting}
translate(Num) ->
       case Num of
        0 ->
         "querydesc";
        _ ->
         false
       end.
\end{lstlisting}

Ahhoz, hogy ezt ki is próbálhassuk, a szenzor kódjában a querydesc
függvényt implementálni kell:

\begin{lstlisting}
querydesc() -> rpc({querydesc}).
\end{lstlisting}

Valamint a loop/0 függvényben egy új esetet kell felvenni:

\begin{lstlisting}
        {From, {querydesc}} ->
         From ! {sensor, get(desc)},
         loop();
\end{lstlisting}

\subsection{Felhasználói felület}

Idáig alapvetõen azzal foglalkoztunk, hogy hogyan tudunk adatokat küldeni Erlang node-ok között.

A felhasználói felület feladata, hogy az idáig elkészült middleware-t
felhasználva a felhasználók számára is hasznos támogatást nyújtson,
ezáltal tényleges életviteli rendszert megvalósítva.

Felhasználói felületünk kialakítását kezdjük a szenzorral. A start/1
függvény idáig visszatért ha sikeres volt az üzeneteket kezelõ process
regisztrációja terminal néven. Most ezt megváltoztatjuk, és
interaktívan, a standard bemenetrõl fogunk beolvasni értékeket, majd
azonnal jelzünk ha a felhasználó ENTER-t ütött.

Ehhez a szenzor kódjában a start/1 függvényt változtatjuk meg:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E])
 end, Centers),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)),
 io:format("Adja meg a mert adatot 'tipus szam' formaban, majd usson ENTER-t!\n"),
 io:format("A testhomerseklet merese utan peldaul 'h 38.2'\n"),
 read_stdin(Centers).
\end{lstlisting}

Az újonnan bevezetett read\_stdin függvény pedig:

\begin{lstlisting}
read_stdin(Centers) ->
 L = io:get_line("> "),
 [A|[B]] = re:split(L, " "),
 Desc = list_to_atom(binary_to_list(A)),
 {Data, _} = string:to_float(binary_to_list(B)),
 lists:foreach(fun({C, E}) ->
  Message = {Data, Desc, node(), E, false},
  rpc:call(C, center, notify, [Message])
 end, Centers),
 read_stdin(Centers).
\end{lstlisting}

A feladat második fele pedig a terminál átalakítása, azt szeretnénk,
hogyha a hõmérséklet értéke meghaladja 37.2 fokot, akkor csipogjon.
Egyéb esetben pedig egyszerûen adjon barátságos kimenetet.

Ehhez a terminal modul loop/0 függvényét a következõképpen módosítjuk:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {terminal, pong},
   loop();
  {From, {notify, Message}} ->
   {Data, Desc, _Fro, _To, _Recv} = Message,
   case Desc of
    h ->
     case Data > 37.2 of
      true ->
       io:fwrite([7]),
       io:format("Figyelem, a homerseklet ~p homerseklet tobb a megengedettnel!~n", [Data]);
      _ ->
       io:format("Uj homerseklet adat: ~p.~n", [Data])
      end;
    _ ->
     io:format("A '~p' uj erteke: ~p.~n", [Desc, Data])
   end,
   From ! {terminal, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

\subsection{Hibatûrés}

A rendszerrel szemben elvárás, hogy hibatûrõ legyen, azonban ezt idáig
nem valósítottuk meg, például ha hõmérsékletnek nem lebegõpontos számot
adunk meg, akkor nem kapunk semmilyen hibát, egyszerûen hibás lesz a
mûködés.

Két feladatunk van tehát:

\begin{itemize}
\item A hiba esetén biztosítani, hogy leálljon az adott process, mielõtt
az hibás mûködéshez vezetne.
\item A leállt process helyébe újat indítani.
\end{itemize}

A leállás biztosításához a terminal:read\_stdin/0 függvényt a következõképpen
módosíthatjuk:

\begin{lstlisting}
read_stdin(Centers) ->
 L = io:get_line("> "),
 [A|[B]] = re:split(L, " "),
 Desc = list_to_atom(binary_to_list(A)),
 {Data, _} = string:to_float(binary_to_list(B)),
 case Data of
  error ->
   erlang:error(badarg);
  _ ->
   lists:foreach(fun({C, E}) ->
      Message = {Data, Desc, node(), E, false},
      rpc:call(C, center, notify, [Message])
    end, Centers),
   read_stdin(Centers)
 end.
\end{lstlisting}

Az új process indítása két lépéses folyamat. Elõször is definiálni kell
egy függvényt, mely akkor hívódik meg, ha az aktuális process leáll:

\begin{lstlisting}
on_exit(Pid, Fun) ->
 spawn(fun() ->
  process_flag(trap_exit, true),
  link(Pid),
  receive
   {'EXIT', Pid, _Why} ->
    Fun()
  end
 end).
\end{lstlisting}

Valamint a start/1 függvényben ezt a függvényt regisztrálnunk kell:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E])
 end, Centers),
 catch unregister(sensor),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)),
 on_exit(self(),
  fun() ->
    io:format("A szenzor hibaval lepett ki, ujrainditas...~n"),
    start(ConfigFile)
  end),
 io:format("Adja meg a mert adatot 'tipus szam' formaban, majd usson ENTER-t!\n"),
 io:format("A testhomerseklet merese utan peldaul 'h 38.2'\n"),
 read_stdin(Centers).
\end{lstlisting}
