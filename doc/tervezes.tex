\section{Az Erlang-alapú életviteli rendszer terve}

Az általunk tervezett életviteli rendszer legfontosabb ismérve tehát az
lesz, hogy Erlang környezetben valósítjuk meg. Ezen fejezet célja
specifikálni a követelményrendszert, és e specifikáció néhány
jellegzetes elemét fogjuk megvalósítani a következõ fejezetben.

\subsection{Fõ követelmények}

\subsubsection{Elosztottság}

Elosztott rendszert tervezünk, ez a jelen esetben azt jelenti, hogy
nincs központi eleme a rendszernek, és ez által nincsen egyetlen olyan
elem sem, amelynek a meghibásodása esetén az egész rendszer leállna. Egy
egyszerû példa: az idõs ember elhagyja az ágyát, majd a lakását is, és
megadott idõn belül nem tér vissza. Két szenzor is jelez a türelmi idõ
letelte után. A rendszer lehetõséget ad arra, hogy egy szenzor több
központnak is jelezzen, valamint azt, is, hogy egy központban ugyanarról
a jelzésrõl többen is értesítést kapjanak. Természetesen a redundanciát
tovább is fokozhatjuk, de ha ezt nem is tesszük, akkor is a következõkre
számíthatunk:

\begin{itemize}
\item Legrosszabb esetben is kieshet egy elem, és a rendszerünk
tökéletesen fog tovább üzemelni.
\item Két elem kiesésekor már fennáll a veszélye annak, hogy gond lesz,
például ha a két szenzor esik ki.
\item Legjobb esetben három elem is kieshet: ha pont az egyik szenzor,
az egyik központ és az egyik terminál esik ki.
\end{itemize}

A redundancián, mint az életviteli rendszerek szempontjából a leginkább
szembetûnõ elõnyön kívül azonban más pozitívumai is lehetnek egy
elosztott rendszernek. Említésre méltó, hogy a terminálok akár
leválasztott (hálózati kapcsolat nélküli) állapotban is hozzáférnek a
korábban megkapott üzenetekhez, valamint ha ezek között keresni akarnak,
az szintén gyorsabb lesz, mint egy központosított rendszer esetén,
hiszen nem kell hálózati késleltetéssel számolni.

\subsubsection{A rendszer elemei}

\paragraph*{Csomópontok}

Elosztott rendszer lévén a rendszer \emph{csomópontokból} épül fel. A
csomópontoknak két fontosabb fajtáját különböztetjük meg: a
\emph{központokat} és a \emph{végpontokat}.

\paragraph*{Központok}

Egy központ bekapcsolás után nem tesz semmit, csak vár arra, hogy
végpontok keressék. Ha egy végpont központot keres, akkor válaszol. Ha
egy végpont regisztrál, akkor nevet ad neki, és erre a névre más
végpontok feliratkozhatnak. Ilyen módon a végpont úgy küldhet üzenetet,
hogy nem tudja, pontosan ki fogja megkapni. Ténylegesen csak a
központnak küldi el, majd a központ küldi tovább a feliratkozott
végpontoknak.

A központ nem rejti el az eredeti feladót, az üzenetet kapott végpontnak
lehetõsége van válaszolni az eredeti feladónak, ha
például döntés szükséges. Ebben az esetben az üzenet közvetlenül kerül
átvitelre a két végpont között, központok igénybevétele nélkül.

A központ ezenkívül hajlandó kiadni egy név mögött álló szenzor címét
is, ez akkor hasznos, hogyha a végpont tudja a számára érdekes szenzor
nevét, de az aktuális címét nem, valamint a szenzor sose ad ki magáról
adatot implicit módon, így más módon a végpont nem szerezhetne tudomást
a szenzor címérõl.

\paragraph*{Végpontok}
A végpontok bekapcsolás után szórt üzenetet küldenek, majd várnak, amíg
legalább egy központ válaszol a kérésre.  A végpontoknak két fajtáját
különböztetjük meg. Ezek egymástól sokkal inkább logikailag, mintsem
technikailag különböznek.

\paragraph*{Szenzorok}
A \emph{szenzorok} olyan érzékelõk, melyek a környezetrõl szolgáltatnak
információt. Ez az információ-adás lehet implicit vagy explicit.
Implicit esetben azt értjük, ha például egy hõmérõ a mért
hõmérsékletet óránként elküldi az általa ismert központoknak. Explicit
esetben viszont egy másik végpont kérésére, közvetlenül a másik
végpontnak bármikor elküldheti a kért adatot. Láthatjuk, hogy az
implicit esetet nem elõzi meg kérés-üzenet, míg explicit esetben mindig
csak egy végpont kap értesítést.

Egy érdekes probléma annak a jelenségnek a kezelése, mely olyan
szenzorok integrálásakor merül fel, melyek folyamatosan mérnek. Ezeket
nem lehet explicit módon lekérdezni, viszont az összes mért adat
implicit közlése indokolatlanul nagy hálózati forgalmat és adatmennyiséget generálna. Ezt a
problémát úgy küszöbölhetjük ki -- ezáltal ezt a szenzor-típust
beillesztve a fenti két szenzor-kategóriába --, hogy a mûszer elé
teszünk egy modult, mely mindig tárolja az utoljára mért értéket. Így a
legutóbbi mért adat explicit módon bárkinek bármilyen idõpontban
elérhetõvé válik.

Egy másik tulajdonság, melyben a szenzorok különbözhetnek, a
vezérelhetõség.

Például egy hõmérõ esetében a legtöbbször nincs mit vezérelni, ellenben
egy ház ajtajába szerelt zár esetén megoldható, hogy ne csak lekérdezni
tudjuk, hanem a zár állapotát vezérelni is lehessen.

\paragraph{Terminálok}
A \emph{terminálok} olyan végpontok, melyek elsõsorban üzenetek
fogadására hivatottak, tehát bekapcsolás után keresnek legalább egy
központot, valamint vagy elõre beállított, vagy a felhasználó által
interaktívan beállítható módon feliratkoznak a központ(ok)
névszolgáltatása által adott eseményekre. A terminál lehet
passzív, mint például egy képernyõ, vagy aktív, például egy
mobiltelefon. Az aktív terminálok reagálhatnak egy-egy üzenetre, míg a
passzívok csak tájékoztató üzeneteket képesek megjeleníteni.

Egy lehetséges szcenárió például a következõ: a tûzjelzõ jelez a központnak, a
központ továbbítja az üzenetet egy telefonra, ott a célszemély egy
üzenetet küld a tûzjelzõt tartalmazó lakás ajtajában lévõ zárnak, hogy
az adja meg az állapotát, az válaszol közvetlenül a telefonra, hogy
zárva van, majd a célszemély úgy dönt, hogy ez az állapot nem kívánatos,
és egy olyan vezérlõ-üzenetet küld a zárnak, hogy az nyíljon ki. Ez a
folyamat akár meg is mentheti egy idõs ember életét, aki nem képes a
nagy füstben kinyitni a zárat, ellenben az egyszerûen kilinccsel
nyitható ajtón keresztül már képes elhagyni a lakást.

\subsubsection{Dinamizmus}

Volt már szó arról, hogy minden csomópont futási idõben
képes változtatni azon csomópontok listáját, amelyekkel kommunikálni
képes. Központok esetén ez azt jelenti, hogy egy új szenzor
regisztrációjakor nem kell a rendszert újraindítani, a végpontok pedig
bármikor lekérhetik egy üzenetbõl az eredeti feladót, vagy egy központ
névszolgáltatásán keresztül egy, a név mögött álló szenzor címét, majd
annak üzenetet küldhetnek. Ezek az igények nélkülözhetetlenek a rendszer
mûködéséhez.

Amire viszont elsõ körben nem biztos, hogy gondolnánk, az az, hogy a
központoknak különbözõ típusú szenzorokat kell kezelniük, és ez
korántsem egyszerû feladat. A probléma az, hogy minden szenzor más módon
hajlandó adatokat szolgáltatni. Még ha feltételezzük is, hogy minden
szenzor egyben Erlang csomópont is, akkor is más üzenetet kell küldeni egy
hõmérõnek (például \texttt{getTermperature()}), és mást egy
vérnyomásmérõnek (például \texttt{getBloodPressure()}). Ezek egységes
kezeléséhez a központban meghajtóprogramok szükségesek.

A megoldás az, hogy minden szenzortípus egyedi
azonosítóval rendelkezik, ezt elküldi a központnak, a központ az
azonosító alapján letölt egy meghajtóprogramot, betölti, és onnantól tudja, hogy
hogyan kell kezelni.

\subsubsection{Biztonság}

Az elõzõ alfejezet címérõl, a dinamizmus szóról még egy jelenség
juthat eszünkbe: amíg mûködik, addig jó, de ha valami gond van a
rendszerrel, akkor bajban vagyunk, hiszen egy dinamikusan mûködõ
rendszerben hibát keresni nem kellemes feladat. Ha tovább keressük a
problémákat a dinamizmussal, akkor felmerül az a kérdés is, hogy milyen
biztonsági kockázatokat hozunk be ezzel a rendszerbe.

A két probléma látszólag összefügg, de valójában független. Az intelligens,
plug-and-play rendszerekre valós igény van, különösen idõs emberek esetében, hiszen õk
nem szakemberek, így nem várható el, hogy hosszabb tanulás elõzi meg a
rendszer használatát. Tekintve, hogy elsõsorban õértük jön létre a
rendszer, ezt nem hagyhatjuk figyelmen kívül. A másik cél -- a rendszer
üzemeltetõinek szemszögébõl -- természetesen az, hogy minél inkább kontroll
alatt legyen a rendszer, manuálisan beállítva a paramétereket, hogy a nem várt
viselkedést elkerüljük. Sajnos a két célt nem lehet kifogástalanul
teljesíteni egyszerre, de találhatunk olyan kompromisszumos megoldást,
mely mindkét fél tûréshatárán belül helyezkedik el.

A biztonság kérdése annyiban kapcsolódik az elõzõ problémához, hogy egy
biztonságos rendszer egyik alapfeltétele, hogy minden, a rendszer
számára érdekes objektum azonosítva legyen, ami jelen esetben azt
jelentené, hogy a felhasználók és az eszközök is valamilyen
autentikációs mechanizmus teljesítése után válhassanak csak a rendszer
részévé. Ez problémát jelenthet például egy idõs embernél, aki
telefonálni se tud, mikor elesett, nemhogy jelszavakat megadni, mielõtt
értesítené a központot. Ezzel ellentétes igény, hogy ne helyezhessen el
bárki egy terminált az ablakunk alatt, mely azonnal értesíti a támadót,
ahogy elhagytuk a lakást.

Jelen munkában ezt a felmerülõ két problémát úgy oldjuk meg, hogy
feltételezzük a közvetkezõket:

\begin{itemize}
	\item A központoknak van interaktív felhasználói felülete.
	\item A központokhoz fizikailag csak olyan személy fér hozzá,
akinek van is jogosultsága ehhez.
	\item A rendszer minden végpontja egyedi azonosítóval
rendelkezik, melyet nem tud megváltoztatni.
	\item A kommunikációra használt csatorna biztonságos. (Vagy
titkosított, vagy zárt a hálózat.)
	\item Ha a központokhoz új szenzor vagy terminál próbál
csatlakozni, akkor azt elsõ alkalommal a központban jóvá kell
hagyni. Legalább az elsõ végpont jóváhagyását fizikailag a központban
kell elvégezni. (Innentõl az engedélyezett eszköz távolról is
engedélyezhet más eszközöket.)
\end{itemize}

Ezekkel a feltételekkel idõs emberek is könnyen integrálhatnak új,
gyárilag a rendszerrel kompatibilisnek tervezett eszközöket a
rendszerbe, anélkül, hogy potenciális biztonsági réseket hagynánk abban.

Összehasonlításképpen megemlítjük, hogy hasonló jellegû probléma merül
fel Bluetooth rendszerek esetén, egy ,,önlejátszó'' CD számítógépbe tétele
esetén, és még sok más példát lehetne hozni. A Bluetooth rendszer esetén
a megoldás az lett, hogy ha két eszköz kommunikálni akar, akkor azokat
egyszer párosítani kell, és ehhez a mechanizmushoz egy korábban
egyeztetett jelszót kell megadni. Ha mindkét oldalon ugyanazt a jelszót
adják meg, akkor a párosítás sikerült. Az CD-k esetében Windows
operációs rendszer esetén úgy döntöttek, hogy alapértelmezésben
figyelmeztetés nélkül elindul a program, amint behelyeztük a CD-t a
meghajtóba. Ezt természetesen tiltani lehet, és a biztonsági kérdésekre
kicsit komolyabban odafigyelõ felhasználók ezt meg is teszik.
Ellenpéldaként lehetne felhozni a legtöbb UNIX operációs rendszert, ahol
a CD automatikus csatolása vagy fel se merül problémaként, vagy a
felhasználóbarátabb rendszerekben is alapértelmezésként csak jelzést
kap a felhasználó a CD behelyezésérõl, de automatikus csatolásra
felhasználói interakció nélkül soha nem kerül sor.

\subsubsection{Határok}

A fõ követelmények áttekintésének végén megjegyezzük azt, amire már a
bevezetõben is utaltunk: jelen munka célja egy életviteli rendszer
köztes rétegének kidolgozása. Szándékosan nem foglalkozunk tehát a
következõkkel:

\begin{itemize}
\item Skálázhatósági kérdések. A rendszerben típusonként kis számú
elem található meg, kisebb finomítások szükségesek lehetnek, ha a
rendszert típusonként nagyságrendekkel több elemmel használjuk, ezekre
nem térünk ki.
\item Felhasználói felület. Az egyszerûség kedvéért az összes
csomópont a standard kimenetre (stdout) írja az üzeneteit. Egy tényleges
rendszerben ezt célszerû valamilyen felhasználóbarátabb grafikus vagy
webes felületre cserélni.
\item Távoli karbantartás. A meghajtók automatikus letöltésén kívül egyéb
automatikus kód-letöltéssel nem foglalkozunk, de megjegyezzük, hogy a
meghajtó-letöltéshez hasonló módon az egyes csomópontok teljes szoftverét
frissíthetõvé lehetne tenni. Az Erlang rendszer használata esetén --
ahol futás közben lehet modulokat betölteni vagy frissíteni -- ehhez
nincs is szükség komolyabb erõfeszítésekre.
\end{itemize}

\subsection{Erlang és UML}

A rendszer tervezésekor formális jelölésrendszerként az UML (Unified
Modeling Language) jelöléseit használjuk. Az UML elsõsorban
objektumorientált rendszerek tervezésére készült, míg Joe Armstrong\cite{armstrong}
szerint az Erlang nem objektumorientált nyelv, így a
jelölésrendszer nem használható magyarázat nélkül.

Anélkül, hogy általános megfeleltetést állítanánk fel az
objektumorientált nyelvek fogalmai és az Erlang rendszerben elérhetõ
elemek között, a jelen életviteli rendszer tervezése során a
következõket feltételezzük:

\begin{itemize}
\item Az objektumok az Erlang rendszerben Erlang processzek lesznek.
\item Ha egy Erlang processz üzenetet kap, és az üzenet típusa szerint az
üzenetre más-más módon reagál, azt megfeleltethetjük az objektumok
metódusainak.
\item Szekvenciadiagramok esetén objektumok létrehozásán
\texttt{spawn()} hívásokat értünk, metódushíváson pedig adott típusú
üzenet küldését.
\item Állapotdiagramok esetén az egyes Erlang processzek életciklusát
értjük, hiszen az Erlangban nincsenek frissíthetõ változók, hacsak nem
számolunk egy külsõ adatbázissal.
\end{itemize}

A következõ alfejezetekben tehát az elõzõ alfejezetben kifejtett fõ
szempontokat pontosítjuk, az UML jelöléseit használva.

\subsection{Az elemek katalógusa}

A rendszer tehát a következõ elemekbõl fog állni:

\begin{itemize}
\item Node: a rendszerben lévõ bármilyen csomópont
\item Center: olyan csomópont, mely központ
\item Endpoint: olyan csomópont, mely végpont
\item Sensor: olyan végpont, mely elsõsorban üzeneteket küld
\item Terminal: olyan végpont, mely elsõsorban üzeneteket fogad
\item Message: a csomópontok közötti üzenetek formátumát definiálja
\item Driver: a letölthetõ eszközmeghajtók interfészét definiálja
\end{itemize}

\subsection{Az elemek leírása}

\subsubsection*{Node}

\begin{itemize}
\item Leírás:

Egy Erlang processzt jelöl, mely egyedi, nem megváltoztatható
azonosítóval rendelkezik.

\item Változók:

Id -- Egyedi azonosító, mely nem változtatható meg.

\item Szolgáltatások:

ping() -- Egy pong atommal válaszol, jelezve, hogy a processz fut.
\end{itemize}

\subsubsection*{Center}

\begin{itemize}
\item Leírás:

Olyan Node-ot jelöl, melybe regisztrálhatnak szenzorok,
valamint a regisztrált nevekre feliratkozhatnak terminálok. Csak
továbbítja az üzeneteket, nem tényleges feladó vagy címzett.

\item Változók:

Sensors -- Regisztrált szenzorok név-cím párjait tartalmazó lista.

Subscriptions -- Nevekre feliratkozott terminálok név-cím párjait
tartalmazó lista.

\item Szolgáltatások:

start() -- Center indítása.

stop() -- Center leállítása.

reg(Address, Name) -- Sensor címének regisztrálása névként.

subscribe(Name, Address) -- Névre feliratkozás egy Terminal adott címével.

lookup(Name) -- Sensor nevének feloldása címre.

notify(Message) -- Message feladása továbbítás céljából.
\end{itemize}

\subsubsection*{Endpoint}

\begin{itemize}
\item Leírás:

Olyan Node-ot jelöl, mely csak küld vagy fogad üzeneteket, nem továbbít.

\item Változók:

Messages -- Beérkezett üzenetek listája.

\item Szolgáltatások:

start(Config) -- Endpoint indítása adott beállításokkal.

stop() -- Endpoint leállítása.
\end{itemize}

\subsubsection*{Sensor}

\begin{itemize}
\item Leírás:

Olyan végpontot jelöl, mely a külvilág valamely változásának hatására
üzenetet küld. Támogathat még vezérlést, illetve explicit lekérdezést
is.

\item Változók:

Centers -- Azon központok listája, melyeket értesíteni kell, ha változott
a környezet.

\item Szolgáltatások:

query(Message) -- Lekérdez egy adott funkciót, és a feladó címére
megküldi.

control(Message) -- Beállít egy adott funkciót.
\end{itemize}

\subsubsection*{Terminal}

\begin{itemize}
\item Leírás:

Olyan végpontot jelöl, mely elsõsorban üzenetek fogadására hivatott.
Opcionálisan üzeneteket is lehet vele küldeni, válaszként egy korábban
egy szenzortól kapott üzenetre.

\item Változók:

Centers -- Azon központok listája, melyekre fel kell iratkozni induláskor.

\item Szolgáltatások:

notify(Message) -- Üzenet átadása a terminál számára.
\end{itemize}

\subsubsection*{Message}

\begin{itemize}
\item Leírás:

Egy Erlang ennest jelöl, mely az adat mellett tartalmazza az adat
típusát, feladóját, címzettjét, továbbítóját.

\item Változók:

Data -- Egy szám, a mért érték vagy döntés.

Description -- Ha a szenzor több típusú értéket is mérne, ez mondja meg,
hogy melyik típust jelöli a Data mezõ.

From -- A feladót jelöli.

To -- A címzettet jelöli.

Receiver -- A központot jelöli.
\item Szolgáltatások:

Nincsenek.
\end{itemize}

\subsubsection*{Driver}

\begin{itemize}
\item Leírás:

Egy Erlang függvényt ír le, lehetõvé téve, hogy különbözõ
szenzorokat egységes interfészen át kezeljünk. Az eszközmeghajtónak megküldjük, hogy
melyik Node hányadik funkcióját akarjuk lekérdezni/vezérelni, majd az
megmondja a funkció nevét, amit már az eszköz megért.

Például a \texttt{translate(sensor0@clevo.local, 0)} hatására az adott
meghajtó válasza lehet a \texttt{sugar}, mely egy vérnyomás- és
vércukormérõ esetén a vércukor lekérdezését teszi lehetõvé.

\item Változók:

Nincsenek.
\item Szolgáltatások:

translate(Node, Number) -- Megad egy atomot, melyet metódusnévként
használhatunk ha a szenzort explicit módon akarjuk lekérdezni.
\end{itemize}

\subsection{Statikus struktúradiagram}

%A statikus struktúradiagram \aref{fig:statikus-struktura-diagram}.
%ábrán a rendszer elemeirõl tárolt adatokat, azok összefüggéseit és
%kapcsolatait mutatja.

\begin{figure}[H]
\centering
\includegraphics[width=150mm,keepaspectratio]{statikus-struktura-diagram.eps}
\caption{A rendszer statikus struktúradiagramja}\label{fig:statikus-struktura-diagram}
\end{figure}

A statikus struktúradiagram a rendszer elemeirõl tárolt adatokat, azok
összefüggéseit és kapcsolatait mutatja.

\subsection{Szekvenciadiagramok}

\subsubsection*{Központ indulása}

\begin{figure}[H]
\centering
\includegraphics[width=50mm,keepaspectratio]{kozpont-indulasa.eps}
\caption{Szekvenciadiagram: központ indulása}\label{fig:kozpont-indulasa}
\end{figure}

Az ábrán látható, hogy a központot mindig a felhasználó helyezi üzembe,
és a központ bekapcsolás után belép a várakozási hurokba.

Ebbõl a helyzetbõl aztán majd késõbb a regisztráló vagy riasztó
szenzorok és feliratkozó terminálok mozdíthatják ki.

\subsubsection*{Szenzor regisztrációja}

\begin{figure}[H]
\centering
\includegraphics[width=75mm,keepaspectratio]{szenzor-regisztracioja.eps}
\caption{Szekvenciadiagram: szenzor regisztrációja}\label{fig:szenzor-regisztracioja}
\end{figure}

Az ábra mutatja, hogy a szenzor bekapcsolásakor már legalább egy
központnak bekapcsolt állapotban kell lenni a rendszerben. Ekkor a
szenzor regisztrál, majd a központ elküldi a címét, melyre a szenzor
jelezhet, ha az szükséges.

\subsubsection*{Terminál regisztrációja}

\begin{figure}[H]
\centering
\includegraphics[width=75mm,keepaspectratio]{terminal-regisztracioja.eps}
\caption{Szekvenciadiagram: terminál regisztrációja}\label{fig:terminal-regisztracioja}
\end{figure}

A terminál regisztrációja esetén is elõkövetelmény legalább egy központ
mûködése, ahova feliratkozhat a terminál, de itt a központnak nem kell
azonosítót küldenie, hiszen a terminál nem fogja értesíteni a központot
eseményekrõl.

\subsubsection*{Üzenetküldés szenzorról}

\begin{figure}[H]
\centering
\includegraphics[width=100mm,keepaspectratio]{uzenetkuldes-szenzorrol.eps}
\caption{Szekvenciadiagram: üzenetküldés szenzorról}\label{fig:uzenetkuldes-szenzorrol}
\end{figure}

Az ábra azt mutatja, hogy az üzenetküldés akkor értelmes, ha egy központ
bekapcsolása és a szenzor regisztrációja után legalább egy terminál
feliratkozott az üzenetekre az üzenetküldés elõtt. Ilyenkor a szenzor a
központot értesíti, a központ pedig a terminált.

\subsubsection*{Üzenetküldés szenzorról, redundáns eset}

\begin{figure}[H]
\centering
\includegraphics[width=120mm,keepaspectratio]{uzenetkuldes-szenzorrol-redundans-eset.eps}
\caption{Szekvenciadiagram: üzenetküldés szenzorról redundáns esetben}\label{fig:uzenetkuldes-szenzorrol-redundans-eset}
\end{figure}

Az elõzõ eset általánosítása, ha több szenzort, központot és terminált
helyezünk el a rendszerben. Az ábra két-két példány kommunikációját
mutatja be abban az esetben, ha olyan esemény következik be, melynek
hatására mindkét szenzor jelez.

\subsubsection*{Explicit lekérdezés terminálról}

\begin{figure}[H]
\centering
\includegraphics[width=100mm,keepaspectratio]{explicit-lekerdezes-terminalrol.eps}
\caption{Szekvenciadiagram: explicit lekérdezés terminálról}\label{fig:explicit-lekerdezes-terminalrol}
\end{figure}

Explicit lekérdezés esetén a terminál elõször a központhoz fordul a
szenzor címéért, majd a cím birtokában közvetlenül a szenzornak küld
üzenetet az adatok lekérdezése céljából.

\subsubsection*{Eszköz engedélyezése}

\begin{figure}[H]
\centering
\includegraphics[width=100mm,keepaspectratio]{eszkoz-engedelyezese.eps}
\caption{Szekvenciadiagram: eszköz engedélyezése}\label{fig:eszkoz-engedelyezese}
\end{figure}

Az eszközök engedélyezése esetén az ábrán látható módon elsõ alkalommal,
ha egy szenzor regisztrálni vagy egy terminál feliratkozni akar, akkor a
felhasználónak azt egyszer engedélyeznie kell.
