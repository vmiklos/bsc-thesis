\documentclass[12pt,a4paper,oneside]{article}
\usepackage[magyar, english]{babel}
\ifx\magyarOptions\relax\else 
  \PackageError{magyar.ldf}{http://www.math.bme.hu/latex/}{} 
  \csname @@end\endcsname \fi
\usepackage[latin2]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{times}
\usepackage{fullpage}
\usepackage{setspace}
\usepackage{float}
\usepackage{listings}
\lstset{breaklines=true} 

\let\stdsection\section
\renewcommand\section{\clearpage\stdsection}

% make \paragraph behave like \subsubsubsection
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{0mm} % name, level, indent
{-\baselineskip} % beforeskip
{0.5\baselineskip} % afterskip
{\normalfont\bfseries}}%
\makeatother
\setcounter{secnumdepth}{4}% to get numbered subsections
\setcounter{tocdepth}{4}% to add \paragraph to the ToC

% avoid widow / orphan lines
\widowpenalty=10000
\clubpenalty=10000
\raggedbottom

\begin{document}
\singlespacing
\include{preliminaries}
\onehalfspacing
\include{abstract}
\tableofcontents
\newpage

\include{bevezeto}

\include{bemutatas}

\section{Az Erlang életviteli rendszer terve}

Az általunk tervezett életviteli rendszer legfontosabb ismérve tehát az
lesz, hogy Erlang környezetben valósítjuk meg. Ezen fejezet célja
specifikálni a követelményrendszert, és ezen specifikációnak néhány
jellegzetes elemét fogjuk megvalósítani a következõ fejezetben.

\subsection{Fõ követelmények}

\subsubsection{Elosztottság}

Elosztott rendszert tervezünk, mely alatt jelen esetben azt értjük, hogy
nincs központi eleme a rendszernek, és ez által nincsen egyetlen olyan
elem se, amely meghibásodása esetén az egész rendszer leállna. Egy
egyszerû példa: az idõs ember elhagyja az ágyát, majd a lakását is, és
megadott idõn belül nem tér vissza. Két szenzor is jelez a türelmi idõ
letelte után. A rendszer lehetõséget ad arra, hogy egy szenzor több
központnak is jelezzen, valamint azt, is, hogy egy központban ugyanarról
a jelzésrõl többen is értesítést kapjanak. Természetesen a redundanciát
tovább is fokozhatjuk, de ha ezt nem is tesszük, akkor is a következõkre
számíthatunk:

\begin{itemize}
\item Legrosszabb esetben is kieshet egy elem, és a rendszerünk
tökéletesen fog tovább üzemelni.
\item Két elem kiesésekor már fennáll a veszélye annak, hogy gond lesz,
például ha a két szenzor esik ki.
\item Legjobb esetben három elem is kieshet: ha pont az egyik szenzor,
az egyik központ és az egyik terminál esik ki.
\end{itemize}

A redundancián, mint az életviteli rendszerek szempontjából a leginkább
szembetûnõ elõnyön kívül azonban más pozitívumai is lehetnek egy
elosztott rendszernek. Említésre méltó, hogy a terminálok akár
leválasztott (hálózati kapcsolat nélküli) állapotban is hozzáférnek a
korábban megkapott üzenetekhez, valamint ha ezek között keresni akarnak
az szintén gyorsabb lesz, mint egy központosított rendszer esetén,
hiszen nem kell hálózati késleltetéssel számolni.

\subsubsection{A rendszer elemei}

\paragraph*{Csomópontok}

Ebbõl következõen a rendszer \emph{csomópontokból} épül fel. A
csomópontoknak két fontosabb fajtáját különböztetjük meg: a
\emph{központokat} és a \emph{végpontokat}.

\paragraph*{Központok}

Egy központ bekapcsolás után nem tesz semmit, csak vár arra, hogy
végpontok keressék. Ha egy végpont központot keres, akkor válaszol. Ha
egy végpont regisztrál, akkor nevet ad neki, és erre a névre más
végpontok feliratkozhatnak. Ilyen módon a végpont úgy küldhet üzenetet,
hogy nem tudja, hogy pontosan ki fogja megkapni. Ténylegesen csak a
központnak küldi el, majd a központ küldi tovább a feliratkozott
végpontoknak.

A központ nem rejti el az eredeti feladót, az üzenetet kapott végpontnak
lehetõsége van válaszolni az eredeti feladónak, abban az esetben ha
például döntés szükséges. Ebben az esetben az üzenet közvetlenül kerül
átvitelre a két végpont között, központok igénybevétele nélkül.

A központ ezenkívül hajlandó kiadni egy név mögött álló szenzor címét
is, ez akkor hasznos, hogyha a végpont tudja a számára érdekes szenzor
nevét, de az aktuális címét nem, valamint a szenzor sose ad ki magáról
adatot implicit módon, így más módon a végpont nem szerezhetne tudomást
a szenzor címérõl.

\paragraph*{Végpontok}
A végpontok bekapcsolás után szórt üzenetet küldenek, majd várnak, amíg
legalább egy központ válaszol a kérésre.

\paragraph*{Szenzorok}
A végpontoknak két fajtáját különböztetjük meg. Ezek egymástól sokkal
inkább logikailag, mintsem technikailag különböznek. A \emph{szenzorok}
olyan érzékelõk, melyek a környezetrõl szolgáltatnak információt. Ez az
információ-adás lehet implicit vagy explicit. Implicit eset alatt azt
értjük, ha például egy hõmérõ a mért hõmérsékletet óránként elküldi az
általa ismert központoknak. Explicit esetben viszont egy másik végpont
kérésére, közvetlenül a másik végpontnak bármikor elküldheti a kért
adatot. Láthatjuk, hogy az implicit esetet nem elõzi meg kérés-üzenet,
míg explicit esetben mindig csak egy végpont kap értesítést.

Egy érdekes probléma annak a jelenségnek a kezelése, mely olyan
szenzorok integrálásakor merül fel, melyek folyamatosan mérnek. Ezeket
tehát nem lehet explicit módon lekérdezni, viszont az összes mért adat
implicit közlése indokolatlanul nagy hálóhati forgalmat generálna. Ezt a
problémát úgy küszöbölhetjük ki -- ezáltal ezt a szenzor-típust
beillesztve a fenti két szenzor-kategóriába --, hogy a mûszer elé
teszünk egy modult, mely mindig tárolja az utoljára mért értéket. Így a
legutóbbi mért adat explicit módon bárkinek bármilyen idõpontban
elérhetõvé válik.

Egy másik tulajdonság, melyben a szenszorok különbözhetnek a
vezérelhetõség.

Például egy hõmérõ esetében a legtöbbször nincs mit vezérelni, ellenben
egy ház ajtajába szerelt zár esetén megoldható, hogy ne csak lekérdezni
tudjuk, hanem a zár állapotát vezérelni is lehessen.

\paragraph{Terminálok}
A \emph{terminálok} olyan végpontok, melyek elsõsorban üzenetek
fogadására hivatottak, tehát bekapcsolás után keresnek legalább egy
központot, valamint vagy elõre beállított, vagy a felhasználó által
interaktívan beállítható módon feliratkoznak a központ(ok)
névszolgáltatása által adott eseményekre. A terminálok között lehet
passzív, mint például egy képernyõ, vagy aktív, például egy
mobiltelefon. Az aktív terminálok reagálhatnak egy-egy üzenetre, míg a
passzívok csak tájékoztató üzeneteket képesek megjeleníteni.

Egy gyakorlati példa például, hogy a tûzjelzõ jelez a központnak, a
központ továbbítja az üzenetet egy telefonra, ott a célszemély egy
üzenetet küld a tûzjelzõt tartalmazó lakás ajtajában lévõ zárnak, hogy
az adja meg az állapotát, az válaszol közvetlenül a telefonra, hogy
zárva van, majd a célszemély úgy dönt, hogy ez az állapot nem kívánatos,
és egy olyan vezérlõ-üzenetet küld a zárnak, hogy az nyíljon ki. Ez a
folyamat akár meg is mentheti egy idõs ember életét, aki nem képes a
nagy füstben kinyitni az zárat, ellenben az egyszerûen kilinccsel
nyitható ajtón keresztül már képes elhagyni a lakást.

\subsubsection{Dinamizmus}

Volt már szó arról, hogy értelemszerûen minden csomópont futási idõben
képes változtatni azon csomópontok listáját, amelyekkel kommunikálni
képes. Központok esetén ez azt jelenti, hogy egy új szenzor
regisztrációjakor nem kell a rendszert újraindítani, a végpontok pedig
bármikor lekérhetik egy üzenetbõl az eredeti feladót, vagy egy központ
névszolgáltatásán keresztül egy, a név mögött álló szenzor címét, majd
annak üzenetet küldhetnek. Ezek az igények nélkülözhetetlenek a rendszer
mûködéséhez.

Amire viszont elsõ körben nem biztos, hogy gondolnánk, az az, hogy a
központoknak különbözõ típusú szenzorokat kell kezelniük, és ez
korántsem egyszerû feladat. A probléma az, hogy minden szenzor más módon
hajlandó adatokat szolgáltatni. Még ha feltételezzük, hogy minden
szenzor egy Erlang csomópont is, akkor is más üzenetet kell küldeni egy
hõmérõnek (például \texttt{getTermperature()}), és mást egy
vérnyomásmérõnek (például \texttt{getBloodPressure()}). Ezek egységes
kezeléséhez a központban driverek szükségesek.

A megoldás tehát az lesz, hogy minden szenzor-típus egy egyedi
azonosítóval rendelkezik, ezt elküldi a központnak, a központ az
azonosító alapján letölt egy drivert, betölti, és onnantól tudja, hogy
hogyan kell kezelni.

\subsubsection{Biztonság}

Az elõzõ alfejezet címe kapcsán a dinamizmus szóról még egy jelenség
juthat eszünkbe: amíg mûködik addig jó, de ha valami gond van a
rendszerrel, akkor bajban vagyunk, hiszen egy dimanikusan mûködõ
rendszerben hibát keresni nem kellemes feladat. Ha tovább keressük a
problémákat a dinamizmussal, akkor felmerül az a kérdés is, hogy milyen
biztonsági kockázatokat hozunk be ezzel a rendszerbe.

A két probléma részben összefügg, de valójában független. Az inteligens,
plug-and-play rendszerekre valós igény van idõs embereknél, hiszen õk
nem szakemberek, így nem várható el, hogy hosszabb tanulás elõzi meg a
rendszer használatát. Tekintve, hogy elsõsorban õértük jött létre a
rendszer, ezt nem hagyhatjuk figyelmen kívül. A másik cél -- a rendszer
üzemeltetõinek szemszögébõl -- természetesen, hogy minél inkább kontroll
alatt legyen a rendszer, kézzel állítva mindent, hogy a nem várt
eseményeket elkerüljük. Sajnos a két célt nem lehet kifogástalanul
teljesíteni egyszerre, de találhatunk olyan kompromisszumos megoldást,
mely mindkét fél türéshatárán belül helyezkedik el.

A biztonság kérdése annyiben kapcsolódik az elõzõ problémához, hogy egy
biztonságos rendszer egyik alapfeltétele, hogy minden, a rendszer
számára érdekes objektum azonosítva legyen, ami jelen esetben azt
jelentené, hogy a felhasználók és az eszközök is valamilyen
authentikációs mechanizmus teljesítése után válhassanak csak a rendszer
részévé. Ez problémát jelenthet például egy idõs embernél, aki
telefonálni se tud, mikor elesett, nem hogy jelszavakat megadni, mielõtt
értesítené a központot. Ezzel ellentétes igény, hogy ne helyezhessen el
bárki egy terminált az ablakunk alatt, mely azonnal értesíti a támadót,
ahogy elhagytuk a lakást.

Jelen munkában ezt a felmerülõ két problémát úgy oldjuk meg, hogy
feltételezzük a közvetkezõket:

\begin{itemize}
	\item A központoknak van interaktív felhasználói felülete.
	\item A központokhoz fizikailag csak olyan személy fér hozzá,
akinek van is jogosultsága ehhez.
	\item A rendszer minden végpontja egyedi azonosítóval
rendelkezik, melyet nem tud megváltoztatni.
	\item A kommunikációra használt csatorna biztonságos. (Vagy
titkosított, vagy zárt a hálózat.)
	\item A központokhoz ha új szenzor vagy terminál próbál
csatlakozni, akkor azt elsõ alkalommal ezt a központban jóvá kell
hagyni. Legalább az elsõ végpont jóváhagyását fizikailag a központban
kell elvégezni. (Innentõl az engedélyezett eszköz távolról is
engedélyezhet más eszközöket.)
\end{itemize}

Ezekkel a feltételekkel idõs emberek is könnyen integrálhatnak új,
gyárilag a rendszerrel kompatibilisnak tervezett eszközöket a
rendszerbe, anélkül, hogy potenciális biztonsági réseket hagynánk abban.

Összehasonlításképpen megemlítjük, hogy hasonló jellegû probléma merül
fel Bluetooth rendszerek esetén, egy ,,önlejátszó'' CD számítógépbe tétele
esetén, és még sok más példát lehetne hozni. A Bluetooth rendszer esetén
a megoldás az lett, hogy ha két eszköz kommunikálni akar, akkor azokat
egyszer párosítani kell, és ehhez a mechanizmushoz egy korábban
egyeztetett jelszót kell megadni. Ha mindkét oldalon ugyanazt a jelszót
adják meg, akkor a párosítás sikerült. Az CD-k esetében Windows
operációs rendszer esetén úgy döntöttek, hogy alapértelmezésben
figyelmeztetés nélkül elindul a program, amint behelyeztük a CD-t a
meghajtóba. Ezt természetesen tiltani lehet, és a biztonsági kérdésekre
kicsit komolyabban odafigyelõ felhasználók ezt meg is teszik.
Ellenpéldaként lehetne felhozni a legtöbb UNIX operációs rendszert, ahol
a CD automatikus csatolása vagy fel se merül problémaként, vagy a
felhasználóbarátabb rendszerekben is alapértelmezésként csak jelzést
kap a felhasználó a CD behelyezésérõl, de automatikus csatolásra
felhasználói interakció nélkül soha nem kerül sor.

\subsubsection{Határok}

A fõ követelmények áttekintésének végén megjegyezzük azt, amire már a bevezetõben is utaltunk: jelen munka célja egy életviteli rendszer köztes rétegének kidolgozása. Szándékosan nem foglalkozunk tehát a következõkkel:

\begin{itemize}
\item Skálázhatósági kérdésekkel. A rendszerben típusonként kis számú
elem található meg, kisebb finomítások szükségesek lehetnek ha a
rendszert típusonként nagyságrendekkel több elemmel használjuk, ezekre
nem térünk ki.
\item Felhasználói felülettel. Az egyszerûség kedvéért az összes
csomópont a standard kimenetre (stdout) írja az üzeneteit. Egy tényleges
rendszerben ezt célszerû valamilyen felhasználóbarátabb grafikus vagy
webes felületre cserélni.
\item Távoli karbantartás. A driverek automatikus letöltésén kívül egyéb
automatikus kód-letöltéssel nem foglalkozunk, de megjegyezzük, hogy a
driver-letöltéshez hasonló módon az egyes csomópontok teljes szoftverét
frissíthetõvé lehetne tenni. Az Erlang rendszer használata esetén --
ahol futás közben lehet modulokat betölteni vagy frissíteni -- ehhez
nincs is szükség komolyabb erõfeszítésekre.
\end{itemize}

\subsection{Erlang és UML}

A rendszer tervezésekor formális jelölésrendszerként az UML (Unified
Modeling Language) jelöléseit használjuk. Az UML elõsorban
objektumorientált környezetbe készült, mig Joe Armstrong\cite{armstrong}
szerint az Erlang valójában nem objektumorientált nyelv, így a
jelölésrendszer nem használható magyarázat nélkül.

Anélkül, hogy általános megfeleltetést állítanánk fel az
objektumorientált nyelvek fogalmai és az Erlang rendszerben elérhetõ
elemek között, a jelen életviteli rendszer tervezése során a
következõket feltételezzük:

\begin{itemize}
\item Az objektumok az Erlang rendszerben Erlang processek lesznek.
\item Ha egy Erlang process üzenetet kap, és az üzenet típusa szerint az
üzenetre más-más módon reagál azt megfeleltethetjük az objektumok
metódusainak.
\item Szekvenciadiagramok esetén objektumok létrehozása alatt
\texttt{spawn()} hívásokat értünk, metódushívás alatt pedig adott típusú
üzenet küldését.
\item Állapotdiagramok esetén az egyes Erlang processek életciklusát
értjük, hiszen az Erlangban nincsenek tényleges változók, hacsak nem
számolunk egy külsõ adatbázissal.
\end{itemize}

A következõ alfejezetekben tehát az elõzõ alfejezetben kifejtett fõ
szompontokat pontosítjuk, az UML jelöléseit használva.

\subsection{Az elemek katalógusa}

A rendszer tehát a következõ elemekbõl fog állni:

\begin{itemize}
\item Node: a rendszerben lévõ bármilyen csomópont
\item Center: olyan csomópont, mely központ
\item Endpoint: olyan csomópont, mely végpont
\item Sensor: olyan végpont, mely elsõsorban üzeneteket küld
\item Terminal: olyan végpont, mely elõsorban üzeneteket fogad
\item Message: a csomópontok közötti üzenetek formátumát definiálja
\item Driver: a letölthetõ eszközmeghajtók interfészét definiálja
\end{itemize}

\subsection{Az elemek leírása}

\subsubsection*{Node}

\begin{itemize}
\item Leírás:

Egy Erlang processt jelöl, mely egyedi, nem megváltoztatható
azonosítóval rendelkezik.

\item Változók:

Id -- Egyedi azonosító, mely nem változtatható meg.

\item Szolgáltatások:

ping() -- Egy pong atommal válaszol, jelezve, hogy a process fut.
\end{itemize}

\subsubsection*{Center}

\begin{itemize}
\item Leírás:

Olyan Node-ot jelöl, melybe regisztrálhatnak szenzorok
valamint a regisztrált nevekre feliratkozhatnak terminálok. Csak
továbbítja az üzeneteket, nem tényleges feladó vagy címzett.

\item Változók:

Sensors -- Regisztált szenzorok név-cím párjait tartalmazó lista

Subscriptions -- Nevekre feliratkozott terminálok név-cím párjait
tartalmazó lista

\item Szolgáltatások:

start() -- Center indítása

stop() -- Center leállítása

reg(Address, Name) -- Sensor címének regisztrálása névként

subscribe(Name, Address) -- Névre feliratkozás egy Terminal adott címével

lookup(Name) -- Sensor nevének feloldása címre

notify(Message) -- Message feladása továbbítás céljából
\end{itemize}

\subsubsection*{Endpoint}

\begin{itemize}
\item Leírás:

Olyan Node-ot jelöl, mely csak küld vagy fogad üzeneteket, nem továbbít.

\item Változók:

Messages -- Beérkezett üzenetek listája.

\item Szolgáltatások:

start(Config) -- Endpoint indítása adott beállításokkal

stop() -- Endpoint leállítása
\end{itemize}

\subsubsection*{Sensor}

\begin{itemize}
\item Leírás:

Olyan végpontot jelöl, mely a külvilág valamely változásának hatására
üzenetet küld. Támogathat még vezérlést, illetve explicit lekérdezést
is.

\item Változók:

Centers -- Azon központok listája, melyeket értesíteni kell ha változott
a környezet.

\item Szolgáltatások:

query(Message) -- Lekérdez egy adott funkciót, és a feladó címére
megküldi.

control(Message) -- Beállít egy adott funkciót.
\end{itemize}

\subsubsection*{Terminal}

\begin{itemize}
\item Leírás:

Olyan végpontot jelöl, mely elsõsorban üzenetek fogadására hivatott.
Opcionálisan üzeneteket is lehet vele küldeni, válaszként egy korábban
egy szenzortól kapott üzenetre.

\item Változók:

Centers -- Azon központok listája, melyekre fel kell iratkozni induláskor.

\item Szolgáltatások:

notify(Message) -- Üzenet átadása a terminál számára
\end{itemize}

\subsubsection*{Message}

\begin{itemize}
\item Leírás:

Egy Erlang ennest jelöl, mely egy adat mellett tartalmazza azt, hogy
az adat micsoda, kitõl jött, kinek megy és ki továbbította.

\item Változók:

data -- Egy szám, a mért érték vagy döntés.

description -- Ha a szenzor több típusú értéket is mérne, ez mondja meg,
hogy melyik típust jelöli az adat mezõ.

from -- A feladót jelöli.

to -- A címzettet jelöli.

receiver -- A központot jelöli.
\item Szolgáltatások:

Nincsenek.
\end{itemize}

\subsubsection*{Driver}

\begin{itemize}
\item Leírás:

Egy Erlang függvényt ír le, ezáltal lehetõvé téve, hogy különbözõ
szenzorokat egységes interfészen kezeljünk. A drivernek megküldjük, hogy
melyik Node hányadik funkcióját akarjuk lekérdezni/vezérelni, majd az
megmondja a funkció nevét, amit már az eszköz megért.

Például a \texttt{translate(sensor0@clevo.local, 0)} hatására az adott
driver válasza lehet az \texttt{sugar}, mely egy vérnyomás- és
vércukormérõ esetén a vércukor lekérdezését teszi lehetõvé.

\item Változók:

Nincsenek.
\item Szolgáltatások:

translate(Node, Number) -- Megad egy atomot, melyet metódusnévként
használhatunk ha a szenzort explicit módon akarjuk lekérdezni.
\end{itemize}

\subsection{Statikus struktúra diagram}

%A statikus struktúra diagram \aref{fig:statikus-struktura-diagram}.
%ábrán a rendszer elemeirõl tárolt adatokat, azok összefüggéseit és
%kapcsolatait mutatja.

\begin{figure}[H]
\centering
\includegraphics[width=150mm,keepaspectratio]{statikus-struktura-diagram.eps}
\caption{A rendszer statikus struktúra diagramja}\label{fig:statikus-struktura-diagram}
\end{figure}

A statikus struktúra diagram a rendszer elemeirõl tárolt adatokat, azok
összefüggéseit és kapcsolatait mutatja.

\subsection{Szekvencia diagramok}

\subsubsection*{Központ indulása}

\begin{figure}[H]
\centering
\includegraphics[width=50mm,keepaspectratio]{kozpont-indulasa.eps}
\caption{Szekvencia diagram: központ indulása}\label{fig:kozpont-indulasa}
\end{figure}

Az ábrán látható, hogy a központot mindig a felhasználó helyezi üzembe,
és a központ bekapcsolás után belép a várakozási hurokba.

Ebbõl a helyzetbõl aztán majd késõbb a regisztráló vagy riasztó
szenzorok és feliratkozó terminálok mozdíthatják ki.

\subsubsection*{Szenzor regisztrációja}

\begin{figure}[H]
\centering
\includegraphics[width=75mm,keepaspectratio]{szenzor-regisztracioja.eps}
\caption{Szekvencia diagram: szenzor regisztrációja}\label{fig:szenzor-regisztracioja}
\end{figure}

Az ábra mutatja, hogy a szenzor bekapcsolásakor már legalább egy
központnak bekapcsolt állapotban kell lenni a rendszerben. Ekkor a
szenzor regisztrál, majd a központ elküldi a címét, melyre a szenzor
jelezhet ha az szükséges.

\subsubsection*{Terminál regisztrációja}

\begin{figure}[H]
\centering
\includegraphics[width=75mm,keepaspectratio]{terminal-regisztracioja.eps}
\caption{Szekvencia diagram: terminál regisztrációja}\label{fig:terminal-regisztracioja}
\end{figure}

A terminál regisztrációja esetén is elõkövetelmény legalább egy központ
mûködése, ahova feliratkozhat a terminál, de itt a központnak nem kell
azonosítót küldenie, hiszen a terminál nem fogja értesíteni a központot
eseményekrõl.

\subsubsection*{Üzenetküldés szenzorról}

\begin{figure}[H]
\centering
\includegraphics[width=100mm,keepaspectratio]{uzenetkuldes-szenzorrol.eps}
\caption{Szekvencia diagram: üzenetküldés szenzorról}\label{fig:uzenetkuldes-szenzorrol}
\end{figure}

Az ábra azt mutatja, hogy az üzenetküldés akkor értelmes, ha egy központ
bekapcsolása és a szenzor regisztrációja után legalább egy terminál
feliratkozott az üzenetekre az üzenetküldés elõtt. Ilyenkor a szenzor a
központot értesíti, a központ pedig a terminált.

\subsubsection*{Üzenetküldés szenzorról, redundáns eset}

\begin{figure}[H]
\centering
\includegraphics[width=120mm,keepaspectratio]{uzenetkuldes-szenzorrol-redundans-eset.eps}
\caption{Szekvencia diagram: üzenetküldés szenzorról redundáns esetben}\label{fig:uzenetkuldes-szenzorrol-redundans-eset}
\end{figure}

Az elõzõ eset általánosítása ha több szenzort, központot és terminált
helyezünk el a rendszerben. Az ábra két-két példány kommunikációját
mutatja be abban az esetben ha olyan esemény következik be, melynek
hatására mindkét szenzor jelez.

\subsubsection*{Explicit lekérdezés terminálról}

\begin{figure}[H]
\centering
\includegraphics[width=100mm,keepaspectratio]{explicit-lekerdezes-terminalrol.eps}
\caption{Szekvencia diagram: explicit lekérdezés terminálról}\label{fig:explicit-lekerdezes-terminalrol}
\end{figure}

Explicit lekérdezés esetén a terminál elõször a központhoz fordul a
szenzor címéért, majd a címnek birtokában közvetlenül a szenzornak küld
üzenetet az adatok lekérdeze céljából.

\subsubsection*{Eszköz engedélyezése}

\begin{figure}[H]
\centering
\includegraphics[width=100mm,keepaspectratio]{eszkoz-engedelyezese.eps}
\caption{Szekvencia diagram: eszköz engedélyezése}\label{fig:eszkoz-engedelyezese}
\end{figure}

Az eszközök engedélyezése esetén az ábrán látható módon elsõ alkalommal
ha egy szenzor regisztrálni vagy egy terminál feliratkozni akar, akkor a
felhasználónak azt egyszer engedélyeznie kell.

\section{Megvalósítás}

A megvalósítás során a tervezés folyamán felmerült használati eseteket
fogjuk sorra implementálni. Terjedelmi okokból nem kerül megvalósításra
a teljes funkcionalitás, így célszerû mindjárt az elején definiálni,
hogy mely részletek esetén alkalmazunk egyszerûsítéseket, és hol cél a
teljes megvalósítás.

A tervezés során definiált osztályok, az párhuzamosság, hibatûrés és
elosztottság támogatása a program részét képezik. Az elkészítés során
nyomon fogjuk követni, ahogy a tervezés szakaszában leírt használati
esetek sorra mûködõképessé válnak.

Ami nem kerül teljes megvalósításra:

\begin{itemize}
\item A szenzorok nem automatikusan fedezik fel a központokat, hanem egy
konfigurációs állomány elõre definiálja ezek listáját.
\item A korábban felvetett biztonsági kérdésekkel nem foglalkozunk,
feltételezzük, hogy a rendszer zárt, a rendszer elemei pedig
megbízhatóak.
\item Eltekintünk a grafikus felhasználói felület létrehozásától,
egyszerû parancssoros interfészt biztosítva a felhasználó számára.
\end{itemize}

\subsection{Elsõ, már mûködõ változat}

A legkisebb már mûködõ változata a rendszernek az az eset, mikor a
rendszerben egy szenzor, egy központ és egy terminál van. Mivel ez lesz
minden késõbbi változat alapja, tekintsük át tüzetesen a mûködését. A
késõbbiekben csak az ehhez a változathoz képest eszközölt módosítások
kerülnek ismertetésre.

E változat mûködése során a felhasználó egy központot indít, majd egy
terminált, mely regisztrál a központba, végül egy szenzort, mely indulás
után azonnal értesít. Ezt az értesítést kapja meg a központ, majd
továbbítja a terminálnak.

\subsubsection*{Központ}

A központ három olyan függvényt definiál, mely a process életciklusát
érinti:

\begin{lstlisting}
start() -> register(center, spawn(fun() -> put(sensors, []), put(subscriptions, []), loop() end)).

stop() -> center ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

A start/0 függvény egy új processt indít az aktuális node-on, mely
inicializálja a szenzorok és feliratkozások listáját, majd várakozó
állapotba kerül, ld. késõbb.

A stop/0 függvény ennek az új processnek küld egy üzenetet, melynek hatására az leáll.

A ping/0 függvény kizárólag hibakeresési célokat szolgál a lejjebb
ismertetésre kerülõ rpc/1 függvény felhasználásával, lehetõvé téve, hogy
megvizsgáljuk, hogy a központ válaszképes-e.

További négy függvény pedig a központ tényleges vezérlésére szolgál:

\begin{lstlisting}
reg(Address, Name) -> rpc({reg, Address, Name}).

lookup(Name) -> rpc({lookup, Name}).

subscribe(Name, Address) -> rpc({subscribe, Name, Address}).

notify(Message) -> rpc({notify, Message}).
\end{lstlisting}

Láthatjuk, hogy ezek mind a lenn ismertetett rpc/1 függvény köré épített
csomagoló függvények.

A csomagoló függvények által hívott rpc/1 függvény a következõ:

\begin{lstlisting}
rpc(Q) ->
 center ! {self(), Q},
 receive
  {center, Reply} ->
   Reply
 end.
\end{lstlisting}

A függvény a korábban center néven regisztrált
\footnote{Regisztráció és regisztráció törlése alatt itt az Erlang
rendszer register/2 és unregister/1 függvényeit értjük, mely lehetõséget
biztosít arra, hogy az aktuális node-on Pid-ekhez atomokat rendeljünk.
Ezek a regisztrációk más node-okról nem láthatóak, a teljes rendszer
szintjén nem egyediek, és ezt ki is fogjuk használni.}
processnek küld egy két
elemû ennest, megküldve a saját címét, valamint a tényleges adatokat,
majd a válaszként kapott értékkel tér vissza.

Végül a center néven regisztrált processünk fõ függvénye a következõ:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {center, pong},
   loop();
  {From, {reg, Address, Name}} ->
   io:format("[~p] reg(~p,~p)~n", [node(), Address, Name]),
   Sensors = get(sensors),
   put(sensors, [{Address, Name}| Sensors]),
   From ! {center, ok},
   loop();
  {From, {lookup, Name}} ->
   io:format("[~p] lookup(~p)~n", [node(), Name]),
   Sensors = get(sensors),
   A = [A || {A, N} <- Sensors, N =:= Name],
   From ! {center, {ok,A}},
   loop();
  {From, {subscribe, Name, Address}} ->
   io:format("[~p] subscribe(~p,~p)~n", [node(), Name, Address]),
   Subscriptions = get(subscriptions),
   put(subscriptions, [{Name, Address}| Subscriptions]),
   From ! {center, ok},
   loop();
  {From, {notify, Message}} ->
   io:format("[~p] notify(~p)~n", [node(), Message]),
   {Data, Description, Fro, To, _Receiver} = Message,
   lists:foreach(fun(I) -> rpc:call(I, terminal, notify, [{Data, Description, Fro, To, node()}]) end,
    [A || {N, A} <- get(subscriptions), N =:= To]),
   From ! {center, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

Az egyes beérkezõ üzenetekre tehát a következõ válaszokat adja:

\begin{itemize}
\item A ping atomra mindig pong atommal válaszol.
\item A reg atomra a paraméterként kapott szenzor címét és nevét
regisztrálja a egy listába, melyet a process dictionary-ben tárol, így
késõbb is lehetõvé válik annak módosítása.
\item A lookup atomra a paraméterként kapott névhez tartozó szenzor
címet adja vissza vissza a sensors listából.
\item A subscribe atomra a paraméterként kapott névhez eltárolja a kapott címet.
\item A notify atom esetén egy öt elemû ennest (melynek elemeit a
tervezés során Message néven definiáltuk) vár paraméterként. Ebben
szerepel az, hogy milyen névre szól az üzenet. A központ azoknak a
termináloknak továbbítja az üzenetet, amelyek ilyen névvel iratkoztak
fel, beleírva saját magát, mint továbbító.
\item Végül a stop atomra leállítja az aktuális Erlang node-ot.
\end{itemize}

A másik két elemmel ellentétben itt megfigyelhetõ, hogy a központnak
nincs konfigurációs állománya, valamint elindítása után nincs semmilyen
bekövetkezõ esemény.

\subsubsection*{Terminál}

A struktúra diagramban láthattuk, hogy a Center és a Terminal is egy
Node, így itt is megtalálható a három, a process életciklusával
kapcsolatos függvény:

\begin{lstlisting}
start(ConfigFile) ->
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) -> rpc:call(C, center, subscribe, [E, node()]) end, Centers),
 register(terminal, spawn(fun() -> loop() end)).

stop() -> terminal ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

A start/1 függvény azonban itt egy konfigurációs állományt vár paraméterül. Erre egy példa:

\begin{lstlisting}
{center, center0@clevo.local, event}.
\end{lstlisting}

A konfigurációs állomány szintaxisára az egyetlen megkötés az, hogy
minden egyes sorban egy Erlang termnek kell lennie, mivel ezt fogadja el
a file:consult/1 értelmezõ függvény. A fenti fájlban az egyetlen sor egy
központra való feliratkozást definiál, erre utal a center atom. Az ennes
másik két paramétere a központ címét
\footnote{
A következõ, tesztelésrõl is szóló fejezetben látni fogjuk, hogy mi az
oka annak, hogy a cím ebben a formátumban lett megadva. Általánosságban
a cím egy node-ot és egy gépet azonosító atomból áll, a kukac
karakterrel összekötve.
}
és annak az eseménynek a nevét
definiálja, melyre fel szeretnénk iratkozni az adott központban.

Az indítás során tehát értelmezzük a beállításokat, és a kérésnek
megfelelõen feliratkozunk a központoknál, azok subscribe metódusát
meghívva. Ha ez megtörtént, üzenetre várunk a lenn ismertetésre kerülõ
loop/0 függvény használatával.

A stop/0 és ping/0 feladata és mûködése más ismerõs, a center modulban
definiáltakkal megegyezõ.

A terminálnak egyetlen, a modellben is létezõ metódusa a notify/1:

\begin{lstlisting}
notify(Message) -> rpc({notify, Message}).
\end{lstlisting}

A center:notify/1-hez hasonló módon ez is csak csomagoló függvény az
rpc/1 köré.

A terminal modul maradék része a korábban hivatkozott rpc/1 és loop/0
függvényekbõl áll:

\begin{lstlisting}
rpc(Q) ->
 terminal ! {self(), Q},
 receive
  {terminal, Reply} ->
   Reply
 end.

loop() ->
 receive
  {From, {ping}} ->
   From ! {terminal, pong},
   loop();
  {From, {notify, Message}} ->
   io:format("[~p] notify(~p)~n", [node(), Message]),
   From ! {terminal, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

Az rpc/1 feladata tehát kommunikálni a terminal néven regisztrált
process-szel: az üzenetküldés után válaszra várni, majd azzal
visszatérni. A center modulhoz hasonló módon itt is azért van erre
szükség erre a csomagolásra, mivel terminal néven más node-on más
processt érhetünk el.

A loop/0 függvény pedig üzeneteket vár:

\begin{itemize}
\item A ping és stop atomok az életciklus monitorozására és vezérlésére
szolgálnak a center modullal megegyezõ módon.
\item A notify atomra pedig a terminál egyszerûen a standard kimenetre
küldi a kapott üzenet tartalmát, nem túl felhasználóbarát módon.
\end{itemize}

\subsubsection*{Szenzor}

A sensor modul implementációja a start, stop és ping metódusokra:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E]),
  Message = {Data, desc, node(), E, false},
  rpc:call(C, center, notify, [Message])
 end, Centers),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)).

stop() -> sensor ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

Láthatjuk, hogy a start függvény itt is használ egy konfigurációs
állományt, melynek azonos a formátuma a szenzoréval. A feladata
természetesen más: itt azt adja meg, hogy melyik központnak milyen néven
kell elküldeni a mérési adatainkat.

Az elsõ változat tehát rögtön indulás után küld egy üzenetet a
konfigurációs állományban megadott központba, a megadott eseménynevet
használva, mely arról fogja informálni a terminálokat, hogy a desc
típusú mérési adat értéke data.

A tervezés során a szenzorok explicit lekérdezésének igénye is
felmerült, az ehhez szükséges függvények:

\begin{lstlisting}
query_data(Message) -> rpc({query_data, Message}).

control(Message) -> rpc({control, Message}).

rpc(Q) ->
 sensor ! {self(), Q},
 receive
  {sensor, Reply} ->
   Reply
 end.
\end{lstlisting}

Az elõzõekben megszokott módon ezek is az rpc/1 függvényt hívják,
melynek mûködési elve nem változott a korábbi két modulhoz képest.

A korábban hivatkozott loop/0 függvénye pedig a következõ:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {sensor, pong},
   loop();
  {From, {query_data, {_Data, _Desc, Fro, _To, _Recv}}} ->
   rpc:call(Fro, terminal, notify, [{get(desc), desc, node(), Fro, false}]),
   From ! {sensor, ok},
   loop();
  {From, {control, {Data, _Desc, _Fro, _To, _Recv}}} ->
   put(desc, Data),
   From ! {sensor, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

\begin{itemize}
\item A ping és stop atomok kezelését már ismerjük
\item A query\_data atom hatására a szenzor process dictionary-jébõl lehet lekérdezni.
\item A control atom segítségével pedig vezérelni lehet a szenzort.
\end{itemize}

\subsection{Redundáns mûködés}

A redundáns mûködés két szempontból különbözik az elõzõ alfejezetben
ismertetett változathoz képest:

\begin{itemize}
\item A rendszer indításakor mindhárom elembõl két példányt kell indítani.
\item A terminálok és szenzorok konfigurációs állományába két-ket
központot kell definiálni.
\end{itemize}

Ez utóbbit például a következõképpen tehetjük meg:

\begin{lstlisting}
{center, center0@clevo.local, event}.
{center, center1@clevo.local, event}.
\end{lstlisting}

\subsection{Meghajtóprogramok támogatása}

Meghajtóprogramokra akkor van szükségünk, ha egy általános interfészen
keresztül akarunk elérni egy-egy eszközt, melynek a speciális jellemzõit
nem ismerjük. Tegyük fel, hogy egy szenzor több mérést is képes végezni,
és ezeket számozzuk.  A megvalósított példa esetén a szenzor egy
querydesc/0 függvénnyel rendelkezik, a terminál ezt szeretné explicit
módon lekérdezni, de csak annyit tud, hogy ez a nulladik típusú mérési
funkciója az eszköznek. A driver modul fog abban segíteni, hogy a 0
alapján megkapja a querydesc atomot.

A modul egyetlen translate/2 függvényt definiál az interfészében:

\begin{lstlisting}
sub(Str,Old,New) ->
       RegExp = "\\Q"++Old++"\\E",
       re:replace(Str,RegExp,New,[multiline, {return, list}]).

translate(Node, Num) ->
       Module = sub(sub(atom_to_list(Node), "@", "_"), ".", "_"),
       compile:file(Module),
       Modulea = list_to_atom(Module),
       list_to_atom(Modulea:translate(Num)).
\end{lstlisting}

Az elsõ segédfüggvény node nevébõl a driver modul nevét állítja elõ, A
kukacokat és pontokat aláhúzásjellel helyettesítve. A második pedig az
elõállított modulnév alapján lefordítja a drivert, meghívja annak
translate metódusát, és a kapott értékkel visszatér.

A sensor0\_clevo\_local modul egyetlen translate/1 függvényt definiál:

\begin{lstlisting}
translate(Num) ->
       case Num of
        0 ->
         "querydesc";
        _ ->
         false
       end.
\end{lstlisting}

Ahhoz, hogy ezt ki is próbálhassuk, a szenzor kódjában a querydesc
függvényt implementálni kell:

\begin{lstlisting}
querydesc() -> rpc({querydesc}).
\end{lstlisting}

Valamint a loop/0 függvényben egy új esetet kell felvenni:

\begin{lstlisting}
        {From, {querydesc}} ->
         From ! {sensor, get(desc)},
         loop();
\end{lstlisting}

\subsection{Felhasználói felület}

Idáig alapvetõen azzal foglalkoztunk, hogy hogyan tudunk adatokat küldeni Erlang node-ok között.

A felhasználói felület feladata, hogy az idáig elkészült middleware-t
felhasználva a felhasználók számára is hasznos támogatást nyújtson,
ezáltal tényleges életviteli rendszert megvalósítva.

Felhasználói felületünk kialakítását kezdjük a szenzorral. A start/1
függvény idáig visszatért ha sikeres volt az üzeneteket kezelõ process
regisztrációja terminal néven. Most ezt megváltoztatjuk, és
interaktívan, a standard bemenetrõl fogunk beolvasni értékeket, majd
azonnal jelzünk ha a felhasználó ENTER-t ütött.

Ehhez a szenzor kódjában a start/1 függvényt változtatjuk meg:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E])
 end, Centers),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)),
 io:format("Adja meg a mert adatot 'tipus szam' formaban, majd usson ENTER-t!\n"),
 io:format("A testhomerseklet merese utan peldaul 'h 38.2'\n"),
 read_stdin(Centers).
\end{lstlisting}

Az újonnan bevezetett read\_stdin függvény pedig:

\begin{lstlisting}
read_stdin(Centers) ->
 L = io:get_line("> "),
 [A|[B]] = re:split(L, " "),
 Desc = list_to_atom(binary_to_list(A)),
 {Data, _} = string:to_float(binary_to_list(B)),
 lists:foreach(fun({C, E}) ->
  Message = {Data, Desc, node(), E, false},
  rpc:call(C, center, notify, [Message])
 end, Centers),
 read_stdin(Centers).
\end{lstlisting}

A feladat második fele pedig a terminál átalakítása, azt szeretnénk,
hogyha a hõmérséklet értéke meghaladja 37.2 fokot, akkor csipogjon.
Egyéb esetben pedig egyszerûen adjon barátságos kimenetet.

Ehhez a terminal modul loop/0 függvényét a következõképpen módosítjuk:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {terminal, pong},
   loop();
  {From, {notify, Message}} ->
   {Data, Desc, _Fro, _To, _Recv} = Message,
   case Desc of
    h ->
     case Data > 37.2 of
      true ->
       io:fwrite([7]),
       io:format("Figyelem, a homerseklet ~p homerseklet tobb a megengedettnel!~n", [Data]);
      _ ->
       io:format("Uj homerseklet adat: ~p.~n", [Data])
      end;
    _ ->
     io:format("A '~p' uj erteke: ~p.~n", [Desc, Data])
   end,
   From ! {terminal, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

\subsection{Hibatûrés}

A rendszerrel szemben elvárás, hogy hibatûrõ legyen, azonban ezt idáig
nem valósítottuk meg, például ha hõmérsékletnek nem lebegõpontos számot
adunk meg, akkor nem kapunk semmilyen hibát, egyszerûen hibás lesz a
mûködés.

Két feladatunk van tehát:

\begin{itemize}
\item A hiba esetén biztosítani, hogy leálljon az adott process, mielõtt
az hibás mûködéshez vezetne.
\item A leállt process helyébe újat indítani.
\end{itemize}

A leállás biztosításához a terminal:read\_stdin/0 függvényt a következõképpen
módosíthatjuk:

\begin{lstlisting}
read_stdin(Centers) ->
 L = io:get_line("> "),
 [A|[B]] = re:split(L, " "),
 Desc = list_to_atom(binary_to_list(A)),
 {Data, _} = string:to_float(binary_to_list(B)),
 case Data of
  error ->
   erlang:error(badarg);
  _ ->
   lists:foreach(fun({C, E}) ->
      Message = {Data, Desc, node(), E, false},
      rpc:call(C, center, notify, [Message])
    end, Centers),
   read_stdin(Centers)
 end.
\end{lstlisting}

Az új process indítása két lépéses folyamat. Elõször is definiálni kell
egy függvényt, mely akkor hívódik meg, ha az aktuális process leáll:

\begin{lstlisting}
on_exit(Pid, Fun) ->
 spawn(fun() ->
  process_flag(trap_exit, true),
  link(Pid),
  receive
   {'EXIT', Pid, _Why} ->
    Fun()
  end
 end).
\end{lstlisting}

Valamint a start/1 függvényben ezt a függvényt regisztrálnunk kell:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E])
 end, Centers),
 catch unregister(sensor),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)),
 on_exit(self(),
  fun() ->
    io:format("A szenzor hibaval lepett ki, ujrainditas...~n"),
    start(ConfigFile)
  end),
 io:format("Adja meg a mert adatot 'tipus szam' formaban, majd usson ENTER-t!\n"),
 io:format("A testhomerseklet merese utan peldaul 'h 38.2'\n"),
 read_stdin(Centers).
\end{lstlisting}

\section{Eredmények, jövõbeli munka}

\subsection{Eredmények}

\subsubsection*{Tesztelési környezet}

A tényleges eredmények áttekintése elõtt tekintsük át, hogy milyen
környezetben készült el a munka. A dolgozat tördelése a \TeX{} 3.141592
verziójával készült, Frugalware Linux operációs rendszeren. A programok
teszteléséhez az Erlang R12B-5 verzióját használtam.

A dolgozatban ismertetett kódok kipróbálásának feltétele, hogy az egyes
Erlang node-oknak nevet adjunk. A tesztelés során a következõ
beállításokat használtam:

\begin{itemize}
\item A tesztrendszer két fizikai gépbõl állt: a gyártó, illetve
terméknév után a gépek IP címeit a rendszer \texttt{/etc/hosts}
file-jába \texttt{clevo.local} és \texttt{ibook.local} néven írtam be
mindkét rendszeren.
\item Az Erlang node-ok elnevezésére parancssori kapcsolót használtam.

Példa a \texttt{sensor0} nevû node indítására a \texttt{clevo} gépen:

\begin{lstlisting}
erl -name sensor0@clevo.local
\end{lstlisting}

\item Mikor a tesztelést két node között fizikailag azonos gépen
végeztem, akkor nem volt szükség tudni arról, hogy az Erlang rendszerben
két node akkor kommunikálhat egymással ha azok \emph{cookie-jai}
megegyeznek. Ennek értéke parancssori kapcsolót nem használva a
\texttt{\~/.erlang.cookie} file tartalma, mely ha nem létezik,
automatikusan létrejön és véletlenszerû tartalommal töltõdik fel. Ha
fizikailag két külön gépen tesztelünk, akkor ez a véletlenszerû érték
különbözni fog, és így a tesztelés sikertelen lesz. Erre parancssori kapcsoló használata a megoldás:

\begin{lstlisting}
erl -name sensor0@clevo.local -setcookie s3cr3t
\end{lstlisting}

A másik probléma abból adódott, hogy mindkét gép rendelkezett saját
tûzfallal. Ezt két részproblémára lehetett bontani. Egyrészt az epmd
(Erlang Port Mapper Daemon) fixen az 4369-es porton akar bejövõ
kéréseket kiszolgálni, ezt engedélyezni kell a tûzfalon. Másrészt az
egyes távoli eljáráshívásokhoz egy port-tartományt kell kijelölnünk. Ezt
a következõ opciókkal érhetjük el:

\begin{lstlisting}
erl -name sensor0@clevo.local -setcookie s3cr3t -kernel inet_dist_listen_min minimum inet_dist_listen_max maximum
\end{lstlisting}

A minimum és a maximum értéke egyezhet, például állíthatjuk mind a
kettõt 4370-re. Ha ezek a portok ki és bemenõ forgalma engedélyezett a
tûzfalon, akkor a tûzfal több beállítást már nem igényel.
\end{itemize}


\subsubsection*{Kiindulási állapot, feladat}

A munka megkezdésekor tehát bizonyos ismeretekkel rendelkeztem már az
szekvenciális Erlang programozásával kapcsolatban, valamint adott volt
az fent ismertetett Erlang környezet. A cél pedig egyrészt a hasonló
megoldások felkutatása, valamint az Erlang nyelv alkalmasságának
vizsgálata abból a szempontból, hogy ha egy életviteli rendszert
szeretnénk létrehozni, azt érdemes-e Erlang környezetben megvalósítani.

\subsubsection*{Elért eredmények}

A munka végére világossá vált, hogy egy ilyen rendszer létrehozása
lehetséges, egy kis életviteli rendszert meg is terveztem Erlang
környezetben, valamint néhány jellegzetes elemét meg is valósítottam.

Mint arról korábban szó volt, a megvalósított rendszer legkomolyabb
hiányossága a biztonság megfelelõ granularitású kezelése: ha egy Erlang
node egy másik Erlang node-hoz hozzáférést szerez, onnantól azon
bármilyen kódot futtathat.\cite{afts} Természetesen erre a problémára
több részmegoldás is született, de mindegyiknek meg van a maga
problémája:
\begin {itemize}
\item Választhatjuk, hogy nem használjuk az Erlang elosztott
képességeit, és például egy saját protokollt vezetünk be, és annak
értelmezésekor döntjük el, hogy a bejövõ kéréseket kiszolgáljuk-e vagy
sem. Ekkor sok olyan funkciót kell saját magunknak megvalósítani, melyet
idáig az Erlang nyelvi szinten adott számunkra.

\item Egy másik egyszerû megoldás az, hogy zárt rendszert feltételezünk,
ahol nincsenek megbízhatatlan felhasználók. Ha ezt az esetet bõvítjük
azzal, hogy a kódokat valamilyen technikával aláírjuk, és csak aláírt
kódot hajtunk végre, akkor sok szituációban elegendõ a nyújtott
biztonsági színvonal, például megfelelõ lehet egy kis életviteli
rendszer számára.
\end{itemize}

Azt azonban el kell ismernünk, hogy egyik megoldás sem ad olyan fokú
biztonsági beállítási lehetõségeket, mint amilyeneket például a Java
futtatókörnyezet beépítetten támogat. Ez természetesen érthetõ is,
hiszen az Erlang környezetet eredetileg zárt, telefonos hálózatokba
tervezték, ahol nem volt szükség a jelenleg rendelkezésre állónál
finomabb biztonság-kezelésre.

Mindezek ellenére megállapíthatjuk, hogy egy kis életviteli rendszer
megvalósítása során ki tudjuk használni az Erlang környezet által
nyújtott legfontosabb szolgáltatásokat: az elosztottság hatékony
kezelését, a párhuzamosság jó támogatottságát és a hibatûrési
mechanizmusokat.

\subsection{Jövõbeli munka}

Sok olyan probléma került elõ a munka során, mellyel terjedelmi okokból
nem foglalkoztam, de a jövõben még foglalkozni lehetne. A
legfontosabbak:

\begin{itemize}
\item A felhasználói felületet le lehetne cserélni egy grafikus verzióra.
\item A szenzorok és terminálok jelenleg a beállítási file-jukba
drótozott központokhoz csatlakoznak. Ezt automatizálni lehetne, például
ha feltételezhetnénk, hogy a rendszer alapértelmezett átjárója egyben
egy központ is, vagy ha egy újabb elemet vezetnénk be, amely az
alapértelmezett átjárón fut, és a központok naprakész listáját
szolgáltatná.
\item A mért adatokat jelenleg nem tároljuk semmilyen módon, egy Mnesia
vagy valamilyen SQL adatbázisban való tárolásnak számtalan elõnye lenne.
\item A központ is kaphatna felhasználói felületet, ahol az egyes
eszközöket a tervezés fejezetben ismertetett módon engedélyezni lehetne.
\item A rendszer mûködésének demonstrálása sokkal látványosabb lehetne
valódi szenzorokkal. Az elõzõ félév során az önálló laboratóriumi munka
keretében készült egy vérnyomásmérõhöz Erlang driver, célszerû lenne azt
integrálni ebbe a rendszerbe.
\end{itemize}

\bibliography{szakdolgozat}
\bibliographystyle{unsrt}
\addcontentsline{toc}{section}{Hivatkozások}

\end{document}
