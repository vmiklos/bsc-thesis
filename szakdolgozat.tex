\documentclass[12pt,a4paper,oneside]{article}
\usepackage[magyar, english]{babel}
\ifx\magyarOptions\relax\else 
  \PackageError{magyar.ldf}{http://www.math.bme.hu/latex/}{} 
  \csname @@end\endcsname \fi
\usepackage[latin2]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{times}
\usepackage{fullpage}
\usepackage{setspace}
\usepackage{float}
\usepackage{listings}
\lstset{breaklines=true} 

\let\stdsection\section
\renewcommand\section{\clearpage\stdsection}

% make \paragraph behave like \subsubsubsection
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{0mm} % name, level, indent
{-\baselineskip} % beforeskip
{0.5\baselineskip} % afterskip
{\normalfont\bfseries}}%
\makeatother
\setcounter{secnumdepth}{4}% to get numbered subsections
\setcounter{tocdepth}{4}% to add \paragraph to the ToC

% avoid widow / orphan lines
\widowpenalty=10000
\clubpenalty=10000
\raggedbottom

\begin{document}
\singlespacing
\include{preliminaries}
\onehalfspacing
\include{abstract}
\tableofcontents
\newpage

\include{bevezeto}

\include{bemutatas}

\include{tervezes}

\section{Megvalósítás}

A megvalósítás során a tervezés folyamán felmerült használati eseteket
fogjuk sorra implementálni. Terjedelmi okokból nem kerül megvalósításra
a teljes funkcionalitás, így célszerû mindjárt az elején definiálni,
hogy mely részletek esetén alkalmazunk egyszerûsítéseket, és hol cél a
teljes megvalósítás.

A tervezés során definiált osztályok, az párhuzamosság, hibatûrés és
elosztottság támogatása a program részét képezik. Az elkészítés során
nyomon fogjuk követni, ahogy a tervezés szakaszában leírt használati
esetek sorra mûködõképessé válnak.

Ami nem kerül teljes megvalósításra:

\begin{itemize}
\item A szenzorok nem automatikusan fedezik fel a központokat, hanem egy
konfigurációs állomány elõre definiálja ezek listáját.
\item A korábban felvetett biztonsági kérdésekkel nem foglalkozunk,
feltételezzük, hogy a rendszer zárt, a rendszer elemei pedig
megbízhatóak.
\item Eltekintünk a grafikus felhasználói felület létrehozásától,
egyszerû parancssoros interfészt biztosítva a felhasználó számára.
\end{itemize}

\subsection{Elsõ, már mûködõ változat}

A legkisebb már mûködõ változata a rendszernek az az eset, mikor a
rendszerben egy szenzor, egy központ és egy terminál van. Mivel ez lesz
minden késõbbi változat alapja, tekintsük át tüzetesen a mûködését. A
késõbbiekben csak az ehhez a változathoz képest eszközölt módosítások
kerülnek ismertetésre.

E változat mûködése során a felhasználó egy központot indít, majd egy
terminált, mely regisztrál a központba, végül egy szenzort, mely indulás
után azonnal értesít. Ezt az értesítést kapja meg a központ, majd
továbbítja a terminálnak.

\subsubsection*{Központ}

A központ három olyan függvényt definiál, mely a process életciklusát
érinti:

\begin{lstlisting}
start() -> register(center, spawn(fun() -> put(sensors, []), put(subscriptions, []), loop() end)).

stop() -> center ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

A start/0 függvény egy új processt indít az aktuális node-on, mely
inicializálja a szenzorok és feliratkozások listáját, majd várakozó
állapotba kerül, ld. késõbb.

A stop/0 függvény ennek az új processnek küld egy üzenetet, melynek hatására az leáll.

A ping/0 függvény kizárólag hibakeresési célokat szolgál a lejjebb
ismertetésre kerülõ rpc/1 függvény felhasználásával, lehetõvé téve, hogy
megvizsgáljuk, hogy a központ válaszképes-e.

További négy függvény pedig a központ tényleges vezérlésére szolgál:

\begin{lstlisting}
reg(Address, Name) -> rpc({reg, Address, Name}).

lookup(Name) -> rpc({lookup, Name}).

subscribe(Name, Address) -> rpc({subscribe, Name, Address}).

notify(Message) -> rpc({notify, Message}).
\end{lstlisting}

Láthatjuk, hogy ezek mind a lenn ismertetett rpc/1 függvény köré épített
csomagoló függvények.

A csomagoló függvények által hívott rpc/1 függvény a következõ:

\begin{lstlisting}
rpc(Q) ->
 center ! {self(), Q},
 receive
  {center, Reply} ->
   Reply
 end.
\end{lstlisting}

A függvény a korábban center néven regisztrált
\footnote{Regisztráció és regisztráció törlése alatt itt az Erlang
rendszer register/2 és unregister/1 függvényeit értjük, mely lehetõséget
biztosít arra, hogy az aktuális node-on Pid-ekhez atomokat rendeljünk.
Ezek a regisztrációk más node-okról nem láthatóak, a teljes rendszer
szintjén nem egyediek, és ezt ki is fogjuk használni.}
processnek küld egy két
elemû ennest, megküldve a saját címét, valamint a tényleges adatokat,
majd a válaszként kapott értékkel tér vissza.

Végül a center néven regisztrált processünk fõ függvénye a következõ:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {center, pong},
   loop();
  {From, {reg, Address, Name}} ->
   io:format("[~p] reg(~p,~p)~n", [node(), Address, Name]),
   Sensors = get(sensors),
   put(sensors, [{Address, Name}| Sensors]),
   From ! {center, ok},
   loop();
  {From, {lookup, Name}} ->
   io:format("[~p] lookup(~p)~n", [node(), Name]),
   Sensors = get(sensors),
   A = [A || {A, N} <- Sensors, N =:= Name],
   From ! {center, {ok,A}},
   loop();
  {From, {subscribe, Name, Address}} ->
   io:format("[~p] subscribe(~p,~p)~n", [node(), Name, Address]),
   Subscriptions = get(subscriptions),
   put(subscriptions, [{Name, Address}| Subscriptions]),
   From ! {center, ok},
   loop();
  {From, {notify, Message}} ->
   io:format("[~p] notify(~p)~n", [node(), Message]),
   {Data, Description, Fro, To, _Receiver} = Message,
   lists:foreach(fun(I) -> rpc:call(I, terminal, notify, [{Data, Description, Fro, To, node()}]) end,
    [A || {N, A} <- get(subscriptions), N =:= To]),
   From ! {center, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

Az egyes beérkezõ üzenetekre tehát a következõ válaszokat adja:

\begin{itemize}
\item A ping atomra mindig pong atommal válaszol.
\item A reg atomra a paraméterként kapott szenzor címét és nevét
regisztrálja a egy listába, melyet a process dictionary-ben tárol, így
késõbb is lehetõvé válik annak módosítása.
\item A lookup atomra a paraméterként kapott névhez tartozó szenzor
címet adja vissza vissza a sensors listából.
\item A subscribe atomra a paraméterként kapott névhez eltárolja a kapott címet.
\item A notify atom esetén egy öt elemû ennest (melynek elemeit a
tervezés során Message néven definiáltuk) vár paraméterként. Ebben
szerepel az, hogy milyen névre szól az üzenet. A központ azoknak a
termináloknak továbbítja az üzenetet, amelyek ilyen névvel iratkoztak
fel, beleírva saját magát, mint továbbító.
\item Végül a stop atomra leállítja az aktuális Erlang node-ot.
\end{itemize}

A másik két elemmel ellentétben itt megfigyelhetõ, hogy a központnak
nincs konfigurációs állománya, valamint elindítása után nincs semmilyen
bekövetkezõ esemény.

\subsubsection*{Terminál}

A struktúra diagramban láthattuk, hogy a Center és a Terminal is egy
Node, így itt is megtalálható a három, a process életciklusával
kapcsolatos függvény:

\begin{lstlisting}
start(ConfigFile) ->
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) -> rpc:call(C, center, subscribe, [E, node()]) end, Centers),
 register(terminal, spawn(fun() -> loop() end)).

stop() -> terminal ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

A start/1 függvény azonban itt egy konfigurációs állományt vár paraméterül. Erre egy példa:

\begin{lstlisting}
{center, center0@clevo.local, event}.
\end{lstlisting}

A konfigurációs állomány szintaxisára az egyetlen megkötés az, hogy
minden egyes sorban egy Erlang termnek kell lennie, mivel ezt fogadja el
a file:consult/1 értelmezõ függvény. A fenti fájlban az egyetlen sor egy
központra való feliratkozást definiál, erre utal a center atom. Az ennes
másik két paramétere a központ címét
\footnote{
A következõ, tesztelésrõl is szóló fejezetben látni fogjuk, hogy mi az
oka annak, hogy a cím ebben a formátumban lett megadva. Általánosságban
a cím egy node-ot és egy gépet azonosító atomból áll, a kukac
karakterrel összekötve.
}
és annak az eseménynek a nevét
definiálja, melyre fel szeretnénk iratkozni az adott központban.

Az indítás során tehát értelmezzük a beállításokat, és a kérésnek
megfelelõen feliratkozunk a központoknál, azok subscribe metódusát
meghívva. Ha ez megtörtént, üzenetre várunk a lenn ismertetésre kerülõ
loop/0 függvény használatával.

A stop/0 és ping/0 feladata és mûködése más ismerõs, a center modulban
definiáltakkal megegyezõ.

A terminálnak egyetlen, a modellben is létezõ metódusa a notify/1:

\begin{lstlisting}
notify(Message) -> rpc({notify, Message}).
\end{lstlisting}

A center:notify/1-hez hasonló módon ez is csak csomagoló függvény az
rpc/1 köré.

A terminal modul maradék része a korábban hivatkozott rpc/1 és loop/0
függvényekbõl áll:

\begin{lstlisting}
rpc(Q) ->
 terminal ! {self(), Q},
 receive
  {terminal, Reply} ->
   Reply
 end.

loop() ->
 receive
  {From, {ping}} ->
   From ! {terminal, pong},
   loop();
  {From, {notify, Message}} ->
   io:format("[~p] notify(~p)~n", [node(), Message]),
   From ! {terminal, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

Az rpc/1 feladata tehát kommunikálni a terminal néven regisztrált
process-szel: az üzenetküldés után válaszra várni, majd azzal
visszatérni. A center modulhoz hasonló módon itt is azért van erre
szükség erre a csomagolásra, mivel terminal néven más node-on más
processt érhetünk el.

A loop/0 függvény pedig üzeneteket vár:

\begin{itemize}
\item A ping és stop atomok az életciklus monitorozására és vezérlésére
szolgálnak a center modullal megegyezõ módon.
\item A notify atomra pedig a terminál egyszerûen a standard kimenetre
küldi a kapott üzenet tartalmát, nem túl felhasználóbarát módon.
\end{itemize}

\subsubsection*{Szenzor}

A sensor modul implementációja a start, stop és ping metódusokra:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E]),
  Message = {Data, desc, node(), E, false},
  rpc:call(C, center, notify, [Message])
 end, Centers),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)).

stop() -> sensor ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

Láthatjuk, hogy a start függvény itt is használ egy konfigurációs
állományt, melynek azonos a formátuma a szenzoréval. A feladata
természetesen más: itt azt adja meg, hogy melyik központnak milyen néven
kell elküldeni a mérési adatainkat.

Az elsõ változat tehát rögtön indulás után küld egy üzenetet a
konfigurációs állományban megadott központba, a megadott eseménynevet
használva, mely arról fogja informálni a terminálokat, hogy a desc
típusú mérési adat értéke data.

A tervezés során a szenzorok explicit lekérdezésének igénye is
felmerült, az ehhez szükséges függvények:

\begin{lstlisting}
query_data(Message) -> rpc({query_data, Message}).

control(Message) -> rpc({control, Message}).

rpc(Q) ->
 sensor ! {self(), Q},
 receive
  {sensor, Reply} ->
   Reply
 end.
\end{lstlisting}

Az elõzõekben megszokott módon ezek is az rpc/1 függvényt hívják,
melynek mûködési elve nem változott a korábbi két modulhoz képest.

A korábban hivatkozott loop/0 függvénye pedig a következõ:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {sensor, pong},
   loop();
  {From, {query_data, {_Data, _Desc, Fro, _To, _Recv}}} ->
   rpc:call(Fro, terminal, notify, [{get(desc), desc, node(), Fro, false}]),
   From ! {sensor, ok},
   loop();
  {From, {control, {Data, _Desc, _Fro, _To, _Recv}}} ->
   put(desc, Data),
   From ! {sensor, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

\begin{itemize}
\item A ping és stop atomok kezelését már ismerjük
\item A query\_data atom hatására a szenzor process dictionary-jébõl lehet lekérdezni.
\item A control atom segítségével pedig vezérelni lehet a szenzort.
\end{itemize}

\subsection{Redundáns mûködés}

A redundáns mûködés két szempontból különbözik az elõzõ alfejezetben
ismertetett változathoz képest:

\begin{itemize}
\item A rendszer indításakor mindhárom elembõl két példányt kell indítani.
\item A terminálok és szenzorok konfigurációs állományába két-ket
központot kell definiálni.
\end{itemize}

Ez utóbbit például a következõképpen tehetjük meg:

\begin{lstlisting}
{center, center0@clevo.local, event}.
{center, center1@clevo.local, event}.
\end{lstlisting}

\subsection{Meghajtóprogramok támogatása}

Meghajtóprogramokra akkor van szükségünk, ha egy általános interfészen
keresztül akarunk elérni egy-egy eszközt, melynek a speciális jellemzõit
nem ismerjük. Tegyük fel, hogy egy szenzor több mérést is képes végezni,
és ezeket számozzuk.  A megvalósított példa esetén a szenzor egy
querydesc/0 függvénnyel rendelkezik, a terminál ezt szeretné explicit
módon lekérdezni, de csak annyit tud, hogy ez a nulladik típusú mérési
funkciója az eszköznek. A driver modul fog abban segíteni, hogy a 0
alapján megkapja a querydesc atomot.

A modul egyetlen translate/2 függvényt definiál az interfészében:

\begin{lstlisting}
sub(Str,Old,New) ->
       RegExp = "\\Q"++Old++"\\E",
       re:replace(Str,RegExp,New,[multiline, {return, list}]).

translate(Node, Num) ->
       Module = sub(sub(atom_to_list(Node), "@", "_"), ".", "_"),
       compile:file(Module),
       Modulea = list_to_atom(Module),
       list_to_atom(Modulea:translate(Num)).
\end{lstlisting}

Az elsõ segédfüggvény node nevébõl a driver modul nevét állítja elõ, A
kukacokat és pontokat aláhúzásjellel helyettesítve. A második pedig az
elõállított modulnév alapján lefordítja a drivert, meghívja annak
translate metódusát, és a kapott értékkel visszatér.

A sensor0\_clevo\_local modul egyetlen translate/1 függvényt definiál:

\begin{lstlisting}
translate(Num) ->
       case Num of
        0 ->
         "querydesc";
        _ ->
         false
       end.
\end{lstlisting}

Ahhoz, hogy ezt ki is próbálhassuk, a szenzor kódjában a querydesc
függvényt implementálni kell:

\begin{lstlisting}
querydesc() -> rpc({querydesc}).
\end{lstlisting}

Valamint a loop/0 függvényben egy új esetet kell felvenni:

\begin{lstlisting}
        {From, {querydesc}} ->
         From ! {sensor, get(desc)},
         loop();
\end{lstlisting}

\subsection{Felhasználói felület}

Idáig alapvetõen azzal foglalkoztunk, hogy hogyan tudunk adatokat küldeni Erlang node-ok között.

A felhasználói felület feladata, hogy az idáig elkészült middleware-t
felhasználva a felhasználók számára is hasznos támogatást nyújtson,
ezáltal tényleges életviteli rendszert megvalósítva.

Felhasználói felületünk kialakítását kezdjük a szenzorral. A start/1
függvény idáig visszatért ha sikeres volt az üzeneteket kezelõ process
regisztrációja terminal néven. Most ezt megváltoztatjuk, és
interaktívan, a standard bemenetrõl fogunk beolvasni értékeket, majd
azonnal jelzünk ha a felhasználó ENTER-t ütött.

Ehhez a szenzor kódjában a start/1 függvényt változtatjuk meg:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E])
 end, Centers),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)),
 io:format("Adja meg a mert adatot 'tipus szam' formaban, majd usson ENTER-t!\n"),
 io:format("A testhomerseklet merese utan peldaul 'h 38.2'\n"),
 read_stdin(Centers).
\end{lstlisting}

Az újonnan bevezetett read\_stdin függvény pedig:

\begin{lstlisting}
read_stdin(Centers) ->
 L = io:get_line("> "),
 [A|[B]] = re:split(L, " "),
 Desc = list_to_atom(binary_to_list(A)),
 {Data, _} = string:to_float(binary_to_list(B)),
 lists:foreach(fun({C, E}) ->
  Message = {Data, Desc, node(), E, false},
  rpc:call(C, center, notify, [Message])
 end, Centers),
 read_stdin(Centers).
\end{lstlisting}

A feladat második fele pedig a terminál átalakítása, azt szeretnénk,
hogyha a hõmérséklet értéke meghaladja 37.2 fokot, akkor csipogjon.
Egyéb esetben pedig egyszerûen adjon barátságos kimenetet.

Ehhez a terminal modul loop/0 függvényét a következõképpen módosítjuk:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {terminal, pong},
   loop();
  {From, {notify, Message}} ->
   {Data, Desc, _Fro, _To, _Recv} = Message,
   case Desc of
    h ->
     case Data > 37.2 of
      true ->
       io:fwrite([7]),
       io:format("Figyelem, a homerseklet ~p homerseklet tobb a megengedettnel!~n", [Data]);
      _ ->
       io:format("Uj homerseklet adat: ~p.~n", [Data])
      end;
    _ ->
     io:format("A '~p' uj erteke: ~p.~n", [Desc, Data])
   end,
   From ! {terminal, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

\subsection{Hibatûrés}

A rendszerrel szemben elvárás, hogy hibatûrõ legyen, azonban ezt idáig
nem valósítottuk meg, például ha hõmérsékletnek nem lebegõpontos számot
adunk meg, akkor nem kapunk semmilyen hibát, egyszerûen hibás lesz a
mûködés.

Két feladatunk van tehát:

\begin{itemize}
\item A hiba esetén biztosítani, hogy leálljon az adott process, mielõtt
az hibás mûködéshez vezetne.
\item A leállt process helyébe újat indítani.
\end{itemize}

A leállás biztosításához a terminal:read\_stdin/0 függvényt a következõképpen
módosíthatjuk:

\begin{lstlisting}
read_stdin(Centers) ->
 L = io:get_line("> "),
 [A|[B]] = re:split(L, " "),
 Desc = list_to_atom(binary_to_list(A)),
 {Data, _} = string:to_float(binary_to_list(B)),
 case Data of
  error ->
   erlang:error(badarg);
  _ ->
   lists:foreach(fun({C, E}) ->
      Message = {Data, Desc, node(), E, false},
      rpc:call(C, center, notify, [Message])
    end, Centers),
   read_stdin(Centers)
 end.
\end{lstlisting}

Az új process indítása két lépéses folyamat. Elõször is definiálni kell
egy függvényt, mely akkor hívódik meg, ha az aktuális process leáll:

\begin{lstlisting}
on_exit(Pid, Fun) ->
 spawn(fun() ->
  process_flag(trap_exit, true),
  link(Pid),
  receive
   {'EXIT', Pid, _Why} ->
    Fun()
  end
 end).
\end{lstlisting}

Valamint a start/1 függvényben ezt a függvényt regisztrálnunk kell:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E])
 end, Centers),
 catch unregister(sensor),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)),
 on_exit(self(),
  fun() ->
    io:format("A szenzor hibaval lepett ki, ujrainditas...~n"),
    start(ConfigFile)
  end),
 io:format("Adja meg a mert adatot 'tipus szam' formaban, majd usson ENTER-t!\n"),
 io:format("A testhomerseklet merese utan peldaul 'h 38.2'\n"),
 read_stdin(Centers).
\end{lstlisting}

\section{Eredmények, jövõbeli munka}

\subsection{Eredmények}

\subsubsection*{Tesztelési környezet}

A tényleges eredmények áttekintése elõtt tekintsük át, hogy milyen
környezetben készült el a munka. A dolgozat tördelése a \TeX{} 3.141592
verziójával készült, Frugalware Linux operációs rendszeren. A programok
teszteléséhez az Erlang R12B-5 verzióját használtam.

A dolgozatban ismertetett kódok kipróbálásának feltétele, hogy az egyes
Erlang node-oknak nevet adjunk. A tesztelés során a következõ
beállításokat használtam:

\begin{itemize}
\item A tesztrendszer két fizikai gépbõl állt: a gyártó, illetve
terméknév után a gépek IP címeit a rendszer \texttt{/etc/hosts}
file-jába \texttt{clevo.local} és \texttt{ibook.local} néven írtam be
mindkét rendszeren.
\item Az Erlang node-ok elnevezésére parancssori kapcsolót használtam.

Példa a \texttt{sensor0} nevû node indítására a \texttt{clevo} gépen:

\begin{lstlisting}
erl -name sensor0@clevo.local
\end{lstlisting}

\item Mikor a tesztelést két node között fizikailag azonos gépen
végeztem, akkor nem volt szükség tudni arról, hogy az Erlang rendszerben
két node akkor kommunikálhat egymással ha azok \emph{cookie-jai}
megegyeznek. Ennek értéke parancssori kapcsolót nem használva a
\texttt{\~/.erlang.cookie} file tartalma, mely ha nem létezik,
automatikusan létrejön és véletlenszerû tartalommal töltõdik fel. Ha
fizikailag két külön gépen tesztelünk, akkor ez a véletlenszerû érték
különbözni fog, és így a tesztelés sikertelen lesz. Erre parancssori kapcsoló használata a megoldás:

\begin{lstlisting}
erl -name sensor0@clevo.local -setcookie s3cr3t
\end{lstlisting}

A másik probléma abból adódott, hogy mindkét gép rendelkezett saját
tûzfallal. Ezt két részproblémára lehetett bontani. Egyrészt az epmd
(Erlang Port Mapper Daemon) fixen az 4369-es porton akar bejövõ
kéréseket kiszolgálni, ezt engedélyezni kell a tûzfalon. Másrészt az
egyes távoli eljáráshívásokhoz egy port-tartományt kell kijelölnünk. Ezt
a következõ opciókkal érhetjük el:

\begin{lstlisting}
erl -name sensor0@clevo.local -setcookie s3cr3t -kernel inet_dist_listen_min minimum inet_dist_listen_max maximum
\end{lstlisting}

A minimum és a maximum értéke egyezhet, például állíthatjuk mind a
kettõt 4370-re. Ha ezek a portok ki és bemenõ forgalma engedélyezett a
tûzfalon, akkor a tûzfal több beállítást már nem igényel.
\end{itemize}


\subsubsection*{Kiindulási állapot, feladat}

A munka megkezdésekor tehát bizonyos ismeretekkel rendelkeztem már az
szekvenciális Erlang programozásával kapcsolatban, valamint adott volt
az fent ismertetett Erlang környezet. A cél pedig egyrészt a hasonló
megoldások felkutatása, valamint az Erlang nyelv alkalmasságának
vizsgálata abból a szempontból, hogy ha egy életviteli rendszert
szeretnénk létrehozni, azt érdemes-e Erlang környezetben megvalósítani.

\subsubsection*{Elért eredmények}

A munka végére világossá vált, hogy egy ilyen rendszer létrehozása
lehetséges, egy kis életviteli rendszert meg is terveztem Erlang
környezetben, valamint néhány jellegzetes elemét meg is valósítottam.

Mint arról korábban szó volt, a megvalósított rendszer legkomolyabb
hiányossága a biztonság megfelelõ granularitású kezelése: ha egy Erlang
node egy másik Erlang node-hoz hozzáférést szerez, onnantól azon
bármilyen kódot futtathat.\cite{afts} Természetesen erre a problémára
több részmegoldás is született, de mindegyiknek meg van a maga
problémája:
\begin {itemize}
\item Választhatjuk, hogy nem használjuk az Erlang elosztott
képességeit, és például egy saját protokollt vezetünk be, és annak
értelmezésekor döntjük el, hogy a bejövõ kéréseket kiszolgáljuk-e vagy
sem. Ekkor sok olyan funkciót kell saját magunknak megvalósítani, melyet
idáig az Erlang nyelvi szinten adott számunkra.

\item Egy másik egyszerû megoldás az, hogy zárt rendszert feltételezünk,
ahol nincsenek megbízhatatlan felhasználók. Ha ezt az esetet bõvítjük
azzal, hogy a kódokat valamilyen technikával aláírjuk, és csak aláírt
kódot hajtunk végre, akkor sok szituációban elegendõ a nyújtott
biztonsági színvonal, például megfelelõ lehet egy kis életviteli
rendszer számára.
\end{itemize}

Azt azonban el kell ismernünk, hogy egyik megoldás sem ad olyan fokú
biztonsági beállítási lehetõségeket, mint amilyeneket például a Java
futtatókörnyezet beépítetten támogat. Ez természetesen érthetõ is,
hiszen az Erlang környezetet eredetileg zárt, telefonos hálózatokba
tervezték, ahol nem volt szükség a jelenleg rendelkezésre állónál
finomabb biztonság-kezelésre.

Mindezek ellenére megállapíthatjuk, hogy egy kis életviteli rendszer
megvalósítása során ki tudjuk használni az Erlang környezet által
nyújtott legfontosabb szolgáltatásokat: az elosztottság hatékony
kezelését, a párhuzamosság jó támogatottságát és a hibatûrési
mechanizmusokat.

\subsection{Jövõbeli munka}

Sok olyan probléma került elõ a munka során, mellyel terjedelmi okokból
nem foglalkoztam, de a jövõben még foglalkozni lehetne. A
legfontosabbak:

\begin{itemize}
\item A felhasználói felületet le lehetne cserélni egy grafikus verzióra.
\item A szenzorok és terminálok jelenleg a beállítási file-jukba
drótozott központokhoz csatlakoznak. Ezt automatizálni lehetne, például
ha feltételezhetnénk, hogy a rendszer alapértelmezett átjárója egyben
egy központ is, vagy ha egy újabb elemet vezetnénk be, amely az
alapértelmezett átjárón fut, és a központok naprakész listáját
szolgáltatná.
\item A mért adatokat jelenleg nem tároljuk semmilyen módon, egy Mnesia
vagy valamilyen SQL adatbázisban való tárolásnak számtalan elõnye lenne.
\item A központ is kaphatna felhasználói felületet, ahol az egyes
eszközöket a tervezés fejezetben ismertetett módon engedélyezni lehetne.
\item A rendszer mûködésének demonstrálása sokkal látványosabb lehetne
valódi szenzorokkal. Az elõzõ félév során az önálló laboratóriumi munka
keretében készült egy vérnyomásmérõhöz Erlang driver, célszerû lenne azt
integrálni ebbe a rendszerbe.
\end{itemize}

\bibliography{szakdolgozat}
\bibliographystyle{unsrt}
\addcontentsline{toc}{section}{Hivatkozások}

\end{document}
