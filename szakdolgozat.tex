\documentclass[12pt,a4paper,oneside]{article}
\usepackage[magyar, english]{babel}
\ifx\magyarOptions\relax\else 
  \PackageError{magyar.ldf}{http://www.math.bme.hu/latex/}{} 
  \csname @@end\endcsname \fi
\usepackage[latin2]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{graphicx}
\usepackage{times}
\usepackage{fullpage}
\usepackage{setspace}
\usepackage{float}
\usepackage{listings}
\lstset{breaklines=true} 

\let\stdsection\section
\renewcommand\section{\clearpage\stdsection}

% make \paragraph behave like \subsubsubsection
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{0mm} % name, level, indent
{-\baselineskip} % beforeskip
{0.5\baselineskip} % afterskip
{\normalfont\bfseries}}%
\makeatother
\setcounter{secnumdepth}{4}% to get numbered subsections
\setcounter{tocdepth}{4}% to add \paragraph to the ToC

% avoid widow / orphan lines
\widowpenalty=10000
\clubpenalty=10000
\raggedbottom

\begin{document}
\singlespacing
\include{preliminaries}
\onehalfspacing
\include{abstract}
\tableofcontents
\newpage

\section{Bevezetõ}

Felmérések támasztják alá, hogy az idõsödõ emberek a lehetõ legtovább
szeretnék megõrizni függetlenségüket, otthonukban maradni és a
segítséget ott megkapni. Azaz egyre nagyobb felügyeleti, gondozási és
ápolási kapacitásra lesz szükség.

Az életviteli rendszerek létrehozásakor az a feladatunk, hogy
megtervezzük, hogy hogyan segíthetjük az idõsebbeket és más rászorulókat
abban, hogy otthon, a munkahelyen és szociális kapcsolataikban minél
tovább független, hasznos tagjai maradjanak a társadalomnak.

Az egészségügyi és a szociális ellátás területén kiemelendõ az
idõskorúak, továbbá a fogyatékkal élõk, a betegségbõl felépülõk és a
rehabilitációra szorulók ellátásának, gondozásának, felügyeletének,
ápolásának, önálló életvitelének segítése infokommunikációs eszközök
alkalmazásával, rendszerbe állításával; a táv-diagnosztikai és
távgyógyászati rendszerek elterjedésének elõsegítése, valamint az
otthonápolás támogatása\cite{evita}.

Ahhoz, hogy infokommunikációs eszközeink valóban kiszolgáljanak - és ne
kiszolgáltatottá tegyenek - bennünket, egymással együttmûködni képes és
egyszerûen kezelhetõ eszközökre van szükség, melyhez elengedhetetlen egy
megbízhatóan mûködõ keretrendszer. Ha a keretrendszer stabilitási
problémákkal küzd, vagy funkcionalitásában korlátozza az egyes
eszközöket, akkor hiába fejlesztenek a rendszerhez kiváló modulokat.

Az életviteli rendszerbe kapcsolt infokommunikációs eszközök tehát
elsõsorban abban különböznek a hagyományos társaiktól, hogy az azokat
használó ember felé minimális elvárásokat támasztanak. Egy vérnyomásmérõ
esetén a legjobb, ha maga az eszköz tudja, hogy mikor kell a mérést
elvégezni, és erre figyelmeztetni az illetõt. Mikor a mérés elkészült,
hogy akkor nem szerencsés, ha a mérési eredményt a betegnek kell kézzel
rögzítenie, helyette maga a mûszer rendelkezzen saját memóriával, melyet
vagy azonnal vagy késõbb valamilyen adatbázisba küld. Ezen kívül fontos
szempont, hogy a kezelés minél egyszerûbb legyen.

Például egy mérleg esetén a legjobb, ha a ráhelyezett súly nyomóereje
stabilizálódik akkor automatikusan rögzíti a mérési eredményt, ne
kelljen erre kézzel utasítani.

Az ezzel szemben álló technikai probléma viszont, hogy az eszközök
tipikusan kevés információt árulnak el magukról, így az automatikus
beállítás abban az esetben, ha az eszköz még korábban nem volt a rendszer
része, igencsak nehézkes. Ezen segíthetünk, ha megengedjük, hogy ne
közvetlenül az eszközökkel kommunikáljon a rendszer, hanem az egyes
mûszerekhez készítünk illesztõket, és azt a célt tûzzük ki, hogy minden
(de csak olyan) eszközökkel akarunk együttmûködni, melyek fel vannak
készítve a mi rendszerünkben való mûködésre.

Ezzel elérhetõvé válhat az a használati eset, mikor a vásárló meglátja a
boltban egy eszközön egy rendszer emblémáját, hazaviszi a terméket, és
az azonnal használható, mindenféle beállítás nélkül (vagy minimális
beállítással). Ez a példa kissé elrugaszkodottnak tûnik, azonban ha
figyelembe vesszük az idõsebb emberek igényeit, az elõbbi funkcióra
igenis igény lenne, ha lenne ilyen rendszer.

Mielõtt azonban új rendszer tervezésébe kezdenénk, érdemes megvizsgálni,
hogy jelenleg milyen megoldások, vagy megoldás-kezdemények érhetõek el a
piacon. A problémát alapvetõen két részre lehet bontani. Egyrészt
bármilyen életviteli rendszerhez készítésekor érdemes felhasználni
valamilyen kommunikációs keretrendszert, tehát az ilyen irányú elérhetõ
alternatívákat érdemes mérlegelni, figyelembe véve, hogy milyen igényeink
vannak, és milyen funkcionalitást nyújtanak az egyes jelenleg elérhetõ
implementációk. Másrészt érdemes azt is tanulmányozni, hogy ezekre a
keretrendszerekre milyen jelenleg is mûködõ és elérhetõ életviteli
rendszerek készültek el.

Arra sajnos már elõre fel kell készülni, hogy jelenleg még nem érhetõ el
nyílt szabvány életviteli rendszerekkel kapcsolatban, illetve
esetlegesen jövõbeli ilyen rendszerhez készítendõ mûszerekhez, így a
jelenleg rendelkezésre álló rendszerek sem használhatnak ilyet,
következésképp kevés információt tudhatunk meg róluk. Ennek ellenére
célunk felfedni ezen rendszerek elõnyeit és hátrányait, hogy egy új
rendszer tervezésekor a korábbiak példájából tanulva, ne kövessük el
ugyanazon hibákat újfent.

A jelenleg használt életviteli rendszerekben használt keretrendszerek
tanulmányozásával nem célunk tanulni azok hibáiból, hiszen a jelenlegi
munka kezdetén már eldöntésre került, hogy az új rendszer alapja az
Erlang nyelv és környezet lesz. Ennek ellenére hasznos összehasonlítani
az Erlang által nyújtott funkcionalitást más keretrendszerekkel, ezáltal
is könnyebben rátapinthatunk annak elõnyeire és gyengeségeire.

A korábban már említett zárt beállítottság miatt az elkészült
rendszerekben is inkább a felhasználó oldaláról érzékelhetõ
különbségeket, a rendszer tapasztalható elõnyeit és hátrányait
igyekszünk megmutatni, majd ezen elemzés figyelembevételével nekikezdeni
a saját, Erlang alapú rendszer tervezésének.

Fontos leszögezni, hogy a jelen munka tárgya elsõsorban az életviteli
rendszer megalkotásához szükséges köztes réteg (middleware) megalkotása
Erlang környezetben. Terjedelmi okokból egy teljes életviteli rendszer
megvalósítására sajnos nem térhetünk ki, de megvizsgálunk néhány
jelenleg is elérhetõ megoldást, így reális képet kaphatunk arról, hogy a
tervezett rendszer milyen is lenne teljesen megvalósított állapotában.

A számunkra szükséges funkcionalitást nyújtó keretrendszerre jó példa az
OSGi\cite{osgi}, mely Java nyelven készült és sok olyan problémára nyújt
megoldást, amely a Java alatt dolgozó JVM esetén különös nehézséget
jelent, míg ezek jelentõs hányadára Erlang Beam virtuális gépe nyelvi
szinten nyújt megoldást.

Példaként említhetnénk itt a futási idõben betölthetõ, újratölthetõ és
törölhetõ modulokat, automatikus felügyeletét az egyes monitorozandó
csomópontoknak, vagy rendszerjavítási célból futási idõben kiértékelt
parancsok végrehajtását\cite{pe}.

A jelen bevezetõnek azonban nem célja részletesen specifikálni ezeket a
feladatokat, csak rá akar mutatni a szemmel látható szimmetriára az
Erlang környezet által nyújtott szolgáltatások és az életviteli
rendszerek által igényelt funkcionalitás között.

\subsection{Életviteli rendszerek}

A végfelhasználó számára tényleges segítséget nyújtó életviteli
rendszert valósított meg az angol Tunstall\cite{tunstall} cég. Céljuk
telekommunikációs megoldásokat felhasználni az egészséggondozás
problémakörében, ezzel biztosítva idõsebb emberek számára, hogy hosszabb
távon önellátó módon élhessenek, és hatékonyan gondoskodhassanak saját
egészségükrõl, jó közérzetükrõl.

Az általuk kiemelt fõbb problémakörökre a következõ fejezetben
részletesen kitérünk.

\subsubsection*{Everon}

Hasonló módon kulcsrakész életviteli rendszert hozott létre a finn Oy
Exrei Ab\cite{exrei} cég is, az Everon\cite{everon} márkajelzésû
termékeivel.

Az Exrei cég megoldásai három területre bonthatók:

\begin{itemize}
	\item Személyi biztonság biztosítása. Egy modern vezetéknélüli
riasztó is monitorozó rendszert hoztak létre, mely lehetõséget ad
korlátozott és idõsebb emberek számára, hogy továbbra is otthon
élhessenek. A rendszernek része egy részletes öndiagnosztika, így az
esetek többségében azt is érzékeli, ha maga a rendszer hibásodik.

A rendszer gyakorlatilag egy alapállomásból (base station) épül fel,
ehhez kapcsolódnak szenzorok, illetve vezetéknélküli riasztható
eszközök. Értelemszerûen az alapállomások nem csak a hozzájuk kötõdõ
eszközöket képesek riasztani, hanem megfelelõ biztonsági beállítások
mellett egy másik helyen lévõ alapállomáshoz kötött eszközt is, például
idõs emberek gyermekeinek otthonát. A rendszert kifejezetten úgy
tervezték, hogy leállások ne, vagy nagyon ritkán legyenek csak
szükségesek. A értesítendõ célállomások átirányíthatóak, valamint
lehetõvé válik a rendszeren belül megállapítani egy-egy ember
tartózkodási helyét is. Ajtó-szenzorokkal az is beállítható, hogy az
idõs ember otthonát csak bizonyos idõszakban hagyhassa el, például
megzavarodott állapotban ne induljon neki az éjszakának egyedül.

A rendszer elõnye, hogy független a telefon-hálózattól, illetve annak
kieséseitõl, nem igényli személyi számítógép meglétét a monitorozandó
lakhelyen, az egyes szenzorok ellenállóak (például vízzel szemben), az
egyes eszközök kevés karbantartást igényelnek (például hosszú tartalmú
elemek), valamint az egyes figyelmeztetõ jelzések bármely Everon
alapállomásról bármely másik alapállomásra eljuttathatók.

	\item Biztonsági rendszerek kivitelezése. Az elõzõ pontban
kifejtett rendszerhez kapcsolódhatnak mozgás, ajtó- és egyéb érzékelõk,
melyek egyrész segítenek az emberek védelmében (például tûz esetén kulcs
nélkül is el lehessen hagyni a házat), másrészt viszont támadók ellen is
védenek: ha elhagyták a házat, akkor a mozgásérzékelõ riasztóként is
funkcionál. Ezen kívül idõsebb emberek számára segítséget nyújthat, hogy
a hagyományos kulcs helyett egy engedélyezõ kulcsot hordhatnak magukkal,
melynek jelenlétét a rendszer automatikusan érzékeli, a
beléptetõkártyákhoz hasonló módon.

	\item Tulajdon és berendezés monitorozás. Az elõzõekhez
kapcsolódóan egyéb szenzorokat is fogalmaz a cég, melyek lehetõvé
teszik, hogy házak, autók vagy hasonlóan értékes objektumok hollétét
akár a cég online weblapján keresztül ellenõrizzük, vagy bizonyos
paramétereik megváltozásakor, ill. megadott értéket való felvételükkor
szöveges értesítést kapjunk.
\end{itemize}

\subsubsection*{Vivago}

Magyaroszágon a Sonaris Kft\cite{sonaris} mûködik együtt a finn IST
International Security Technology Oy\cite{ist} céggel, mely a nívódíjas
Vivago\cite{vivago} aktív betegfelügyeleti rendszer megalkotója.

A Vivago rendszernek a magukat csak részben ellátni képes idõsebb
emberek, a krónikus betegségben szenvedõk, fogyatékkal élõk a
célközönsége. A rendszer 24 órás felügyelettel segíti az embereket, mely
automatikusan is képes segítséget hívni, a sérült ember közremûködése
nélkül. Ezen kívül preventív ápolást is biztosít, ez azonban e munka
szempontjából érdektelen.

A korábbiakhoz képest újdonság, hogy a Vivago egy-egy felügyelt beteg
esetén elõször tanuló módban mûködik, tehát méri a személy különbözõ
aktivitásait, majd a tanuló idõszak után képes érzékelni az anomáliákat,
és riasztást eszközölni. Ezáltal lehetõvé válik, hogy ne kelljen kézzel
állítani a riasztási paramétereket, melyek pontos megadása a rendszer
bevezetése során nehézségeket okozhat.

A rendszer konkrétan egy karkötõ jellegû szenzorból, valamint egy, a
lakásban elhelyezendõ segélyállomásból áll, mely egyben kihangosított
telefonként is használható szükség esetén.

A magyarországi forgalmazó ezen kívül ügyeletes ápolót is biztosít, így
megoldódik az a probléma is, ha az értesített családtag a felmerült
probléma megoldásához nem rendelkezik elegendõ kompetenciával.
Természetesen egy rendszer tervezése szempontjából egy ugyanúgy csak egy
értesíthetõ végpontként jelenik meg -- azonban a rendszerek
összehasonlítása szempontjából nem elhanyagolható különbség.

\subsubsection*{Telcomed}

A Telcomed\cite{telcomed} egy ír kereskedelmi cég, pulzusmérõt,
lázmérõt, vérnyomásmérõt, vércukormérõt és hasonló eszközöket forgalmaz.
Egy teljes infrastruktúrát nyújtanak, a betegek otthonától a web-alapú
Telcomed monitorozó központig. Zárt kommunikációs protokollt használnak,
és a megoldásuk nem arra lett tervezve, hogy harmadik fél által gyártott
megoldások integrálhatóak lehessenek a rendszerbe.

\begin{figure}[htp]
\centering
\includegraphics[width=100mm,keepaspectratio]{telcomed.eps}
\caption{A Telcomed rendszer áttekintése}\label{fig:telcomed}
\end{figure}

\subsection{Keretrendszerek}

Egy életviteli rendszer számos csomópontból és végpontból áll. A
végpontok információt fogadhatnak ha riasztás érkezik, valamint
döntéshozatal vagy szenzorok esetén információt küldhetnek is. A
rendszer létrehozásakor a legtöbb probléma már itt jelentkezik: a
végpontokat valamilyen módon a csatlakozási pontokhoz kell kötni, erre
nem volna hátrányos valamilyen szabványos megoldást használni, valamint
el szeretnénk kerülni a kerék feltalálását is.

Ebbõl következik, hogy a rendszert mindenképpen érdemes valamilyen
jelenleg is elérhetõ keretrendszerre építeni, és nem teljesen önálló
egységként létrehozni.

E bevezetõ alfejezet célja ismertetni ezek közül néhány jelenleg is
használatban lévõ megoldást, hogy ezek után legyen viszonyítási alapunk
az Erlang környezet által nyújtott funkcionalitás megítéléséhez.

\subsubsection*{RPC}

Az egyik legelsõ\cite{rpc1} ilyen megoldást a Sun cég specifikálta ki
1988-ban. A szabványt ma is aktívan használják, (e munka írásának
pillanatában) legutolsó verzióját\cite{rpc2} 2009-ben adták ki. A
megcélzott probléma a következõ: adott egy C függvény, és szeretnénk azt
transzparens módon meghívni, de úgy, hogy az egy másik gépen fusson le.
Tehát a kliens oldalon kell egy csonk (stub), mely azonos interfésszel
rendelkezik, mint az eredeti függvény, de az implementáció magában
foglalja a távoli kiszolgálóhoz való csatlakozást, a távoli kódfuttatást,
valamint az eredmény lekérését. A kiszolgáló oldalán szintén szükség
van egy csonk függvényre, mely lehetõvé teszi, hogy az RPC kiszolgáló
kérés esetén meghívja a tényleges implementációját a függvénynek. A
távoli eljáráshíváshoz egy interfészt kell definiálni egy
interfész-leíró nyelvvel (Interface Description Language, IDL), majd
ebbõl a csonkok generálhatóak például az \emph{rpcgen} programmal.

A módszernek manapság az egyik fontos felhasználási területe a hálózati
fájlrendszerek (Network File System, NFS). Hátrányai közül leginkább azt
érdemes megemlíteni, hogy heterogén környezetben, illetve nyitott
hálózaton limitált a funkcionalitása.

\subsubsection*{DCOM}

A DCOM\cite{dcom} (Distributed Component Object Model) technológiát a
Microsoft alkotta meg, a szintén általuk kidolgozott COM (Component
Object Model) kiterjesztéseként. A DCOM nem titkolt szándéka
versenytársként megjelenni a késõbb említésre kerülõ CORBA
architektúrának.

A DCOM mögötti gondolat az volt, hogy a népszerû COM technológiát
továbbfejlesszék, és lehetõvé tegyék az eljáráshívást távoli
számítógépen is. A COM legfontosabb tulajdonsága, hogy lehetõvé tette
alkalmazások számára, hogy egy publikus interfészt definiáljanak, és az
ebben megjelölt függvényeket a gépen futó más alkalmazások meghívják. Az
RPC-hez képest újdonság, hogy az interfészt nem kell elõre tudniuk a
klienseknek, hanem egy \texttt{QueryInterface()} függvényen keresztül az
lekérdezhetõ.

Annak ellenére, hogy alternatív implementációk elérhetõek más
rendszerekre is, ez a technológia igazán csak Windows rendszereken
terjedt el.

\subsubsection*{CORBA}

A CORBA\cite{corba} szabványt az Object Management Group (OMG) dolgozta
ki, célja pedig, hogy több nyelv, több gépen együtt tudjon mûködni,
tehát lehetõvé tegye közöttük a távoli eljáráshívást. Fontos újdonság
még benne, hogy teljes mértékben hordozható.

Az interfész megadása itt is IDL segítségével történik, viszont az is a
szabvány része, hogy az IDL-t, hogyan kell leképezni számos nyelvre.
Természetesen ezen kívül az elõre meghatározott nyelv-listán kívül is
még több nyelvhez elérhetõ a CORBA, de ott az implementáció már nem
szabványosított.

A tényleges távoli eljáráshívás két legfontosabb komponense itt a
objektum kérés bróker (Object Request Broker, ORB -- az alkalmazás más
objektumokkal csak ezen keresztül léphet interakcióba), valamint az
objektum adapter (Object Adapter), amelynek feladata kezelni az
objektumok referencia-számlálóját, figyelni az élettartalmát, és ehhez
hasonló feladatokat ellátni.

\subsubsection*{XML-RPC}

Végezetül megemlítjük az XML-RPC\cite{xmlrpc} szabványt, mely HTTP
protokoll felett, XML használatával oldja meg a távoli eljáráshívást. Az
a megközelítés rendkívül népszerû napjainkban webszolgáltatások esetén,
valamint a Microsoft által a DCOM leváltására megalkotott WCF (Windows
Communications Framework) is belül XML-RPC-t használ.

\section{Egy-egy kiválasztott rendszer részletes ismertetése}

\subsection{A Tunstall életviteli rendszer}

A számos, jelenleg elérhetõ életviteli rendszer közül az angol Tunstall
cég életviteli rendszerét választottuk részletesebb ismertetés céljából.
Ennek oka, hogy az általuk nyújtott szolgáltatásokról részletes
információt tettek elérhetõvé, valamint számokkal, valós életbõl vett
példákkal és esettanulmányokkal szolgálnak az érdeklõdõnek, így engedve
betekintést bármely akár nem kompetens érdeklõdõnek is.

\begin{figure}[htp]
\centering
\includegraphics[width=75mm,keepaspectratio]{tunstall.eps}
\caption{A Tunstall Telehealth Monitor egy Bluetooth alapú vérnyomásmérõvel}\label{fig:tunstall}
\end{figure}

A cég által létrehozott életviteli rendszer számos, a napi életben
elõforduló problémát igyekszik megoldani:

\begin{itemize}
	\item Elmezavar. Gyakori probléma, hogy az ilyen problémákkal
küzdõ emberek elhagyják otthonukat, majd indokolatlanul sok ideig nem
térnek vissza. A cég forgalmaz olyan szenzort, amely adott idõ
elteltével riaszt, ha nem történt meg a hazaérkezés. Egy hasonló
probléma, hogy az ágyból kikelve nem találják az utat a fürdõszoba felé,
vagy vissza, ehhez is létrehoztak egy megoldást, mely érzékeli, hogy
mikor kelt ki az ágyból az ember, és ekkor kapcsolja be a világítást az
útvonal könnyebb megtalálásához. Végül az ilyen emberek sokszor
képtelenek felmérni, hogyha veszélybe keveredtek, és nem teszik meg a
szükséges óvintézkedéseket. A cél füst-, széndioxid- és
földgáz-érzékelõket is forgalmaz, melyek egy központban riasztanak, ha
segítségre van szükség.
	\item Esések. Naponta 8000 idõsebb vagy gyenge ember esik el.
\footnote{Ez, és a többi szám a Tunstall cég által, a jelen írás
pillanatában (2009 október) közölt adatokból való, és Angliára
vonatkozik.}
Ezek 70 százaléka éjszaka történik. Minden ötödik ember, aki eltöri a
csípõjét 6 hónapon belül hal meg. Ebbõl következik, hogy ha egy embernek
félnie kell az eleséstõl, az magával vonja azt az érzést, hogy már nem
képes függetlenül mozogni, valamint hogy már nem él teljes életet. A cég
így két problémakört céloz meg: egyrészt minimálisra csökkenteni az
esések hatását, másrészt növelni az indokolatlanul kis mértékû
önbizalmat. A cég olyan szenzort forgalmaz, mely érzékeli, ha az ember
elhagyta az ágyát, és nem tért vissza meghatározott idõn belül, ami
vélhetõleg arra utal, hogy az illetõ elesett. Az esés-érzékelõ egy
derékszíjon viselt szenzor, mely egyrészt automatikusan érzékelni képes
az esést, valamint egyszerû megoldást ad az elesett ember számára is az
esés jelzésére, így a gyors segítség nyújtása könnyebbé válik. A
harmadik mûszer pedig egy mozgás-érzékelõ, mely akkor riaszt, ha az
ember hosszabb ideje nem mozgott még lakáson belül, mely nagy
valószínûséggel elesést jelent. Ezek az eszközök segítenek megelõzni
olyan eseteket, mikor például egy idõs ember a fürdõszobából visszatérve
elesik a küszöbön, majd az egész éjszakát ott kell töltse, mivel nem tud
segítséget kérni.
	\item Átmeneti biztosítás. Ennek célja, hogy olyan emberek akik
kis segítséggel már otthon gyógyulhatnának, sokszor a kórházban
maradnak, és ott lassabban gyógyulnak, csupán néhány könnyen
kiküszöbölhetõ probléma miatt. Ilyen például az elõzõ pontban említett
esés-érzékelõ, e nélkül egy lábadozó beteget hazaengedni felelõtlenség
lenne.
	\item Tanulási nehézségek. Hetente 200 ember születik tanulási
nehézségekkel. Ez azt jelenti, hogy új vagy összetett információkat,
önállóságot az átlagos embernél nehezebben tanulnak. A cég célja, hogy
ezeknek az embereknek a tanulási nehézségein segítve ne kerüljenek távol
a családjuktól, vagy valamilyen közösség részeként önállóbb életet
tudjanak élni.

Példaként lehetne említeni az elõzõ pontokban is részletezett szenzort,
mely az ágy elhagyásakor és adott idõn belül való vissza nem téréskor
jelez, így értesítve a családtagokat, ha probléma merült fel, míg az
esetek nagy részében a rokonok nyugodtan alhatnak, hiszen a szenzor
jelzésére biztosan felébrednek.
\end{itemize}

A technikai részletekrõl kevesebbet lehet tudni, de azért akadnak kivételek. A
British Telecom\cite{bt} angol telefontársasággal együttmûködve számos
IP-alapú szolgáltatást tettek elérhetõvé. A BT 21 CN\cite{bt21cn} (21st
Century Network) néven elindított programjuk technikai szempontból
leginkább a hagyományos telefonhálózat (PSTN) lecserélése VoIP
megoldásokra. Ez lehetõvé teszi, hogy az egyes végpontokon ne csak
beszédet, hanem sokféle adatforgalmat is lebonyolítsanak az ügyfelek. Ez
a megoldás kiválóan használható a szenzorok által gyûjtött adatok
továbbítására, valamint szükség esetén riasztásra. A Tunstall egy listát
vezet azokról a szenzorokról, melyek a 21CN hálózat felett használt,
általuk bevezetett protokollt támogatni tudják. Sajnálatos módon azonban
nem érhetõ el részletes információ az általuk kifejlesztett, és éles
üzemben is használt protokoll részleteirõl.

\subsection{Az OSGi keretrendszer}

Az OSGI Szövetég (régebbi nevén Open Services Gateway initiative) egy
nyílt szabványügyi szervezet. A szövetség tagjai egy Java-alapú
szolgáltatás-platformot definiáltak, mely távolról kezelhetõ.

A szabvány mögött olyan neves cégek állnak, mint a Nokia, Motorola vagy
az IBM. Leginkább mobil eszközökben használják, de például a népszerû
Eclipse IDE is ezt használja a beépülõ moduljainak kezelésére.  A
szabvány szót itt a hagyományos értelemben használhatjuk, mivel csak a
nyílt forrású implementációkat számolva is többesszámról beszélhetünk.

\begin{figure}[htp]
\centering
\includegraphics[width=100mm,keepaspectratio]{extensions.eps}
\caption{UML szekvenciadiagram, mely Eclipse kiterjesztések mûködését mutatja be, mely OSGi-t használ.}\label{fig:extensions}
\end{figure}

Elõször 2000-ben jelent meg, a jelenleg aktuális 4-es verzióját pedig
2009 szeptemberében adták ki, így méltán tekinthetünk rá, mint aktívan
fejlesztett és karbantartott megoldásra.

A keretrendszer legfontosabb elemei:

\begin{itemize}
	\item Alkalmazások életciklusának kezelési modellje: az
alkamazásokat csomagok (bundle) formájában lehet terjeszteni, majd a JVM
leállítása nélkül telepíteni, elindítani, frissíteni vagy eltávolítani.
	\item Szolgáltatás adatbázis: ez az adatbázis lehetõvé teszi az
alkalmazások számára, hogy értesüljenek he új szolgáltatások érhetõek el
vagy egy szolgáltatás megszûnt, és így alkalmazkodhatnak az új
környezethez.
	\item Végrehajtási környezet: A végrehajtási környezet azt
definiálja, hogy egy környezetben milyen osztályok és metódusok érhetõek
el. A Java Platform, Standard Edition is egy elfogadott OSGi
végrehajtási környezet, de a CDC keretrendszer (amit például a legtöbb
mai mobiltelefon is támogat) is támogatott, valamint van saját, általuk
definiált környezet is. Minden egyes OSGi implementáció maga döntheti
el, hogy milyen végrehajtási környezetet támogat, az elõbbieket a
legtöbb támogatja.
	\item Modulok: Azt is szabványosították, hogy az egyes csomagok
milyen módon tudják az egymás közt fennálló függõségeket, valamint a
kívülrõl elérhetõ API-kat definiálni, lehetõvé téve ezáltal, hogy
egységes módon lehessen az egyes egységekbõl és egységekbe
metódus-hívásokat végezni.
\end{itemize}

\begin{figure}[htp]
\centering
\includegraphics[width=100mm,keepaspectratio]{layering-osgi.eps}
\caption{Az OSGi rétegei}\label{fig:layering-osgi}
\end{figure}

Az egyes csomagok olyan Java könyvtárak (JAR fájlok), amik
OSGi-specifikus fejléccel rendelkeznek a JAR MANIFEST.MF fájljában.

Az egyes alkalmazásoknak a következõ állapotai lehetnek:

\begin{itemize}
	\item Telepítve: Ekkor még elképzelhetõ, hogy egy csomag
függõségei nem állnak rendelkezésre.
	\item Feloldva: Minden függõség elérhetõ, az alkalmazást vagy
leállították, vagy kész az indulásra.
	\item Indul: Az alkalmazás aszinkron módon el lett indítva, de
még nem tért vissza.
	\item Aktív: Az alkalmazás elindult, és még nem kezdeményezték a
leállítását.
	\item Leáll: Az alkalmazás leállítása aszinkron módon
elkezdõdött, de még nem fejezõdött be.
	\item Eltávolítva: Az alkalmazás újabb telepítésig nem indítható
el.
\end{itemize}

A szolgáltatások Java interfészeket jelentenek. Ezeket az API-kat implementálhatják a csomagok, majd ha a csomagot regisztrálták  a szolgáltatás-adatbázisban, akkor a kliensek itt megtalálhatják õket, és innentõl értesítést kérhetnek a szolgáltatás elérhetõsége és el nem érhetõsége esetén.

Az OSGi szabvány is tartalmaz elõre definiált szolgáltatásokat, melyeket három csoportra oszthatunk:

\begin{itemize}
	\item OSGi System Services: ide tartoznak az olyan
rendszerszolgáltatások, mint az eseménykezelõ, a beállításkezelõ,
alkalmazások adminisztrációja, I/O mûveletek, felhasználókezelés.
	\item OSGi Protocol Services: Elõre definiált protokolok
használatát segíti -- HTTP feletti kommunikációt, UPnP-t támogató és
mobil eszközök felé való kommunikációt.
	\item OSGi Miscellaneous Services: Ide tartozik minden egyéb
elõre definiált szolgáltatás, például XML értelmezõ.
\end{itemize}

\section{Az Erlang életviteli rendszer terve}

Az általunk tervezett életviteli rendszer legfontosabb ismérve tehát az
lesz, hogy Erlang környezetben valósítjuk meg. Ezen fejezet célja
specifikálni a követelményrendszert, és ezen specifikációnak néhány
jellegzetes elemét fogjuk megvalósítani a következõ fejezetben.

\subsection{Fõ követelmények}

\subsubsection{Elosztottság}

Elosztott rendszert tervezünk, mely alatt jelen esetben azt értjük, hogy
nincs központi eleme a rendszernek, és ez által nincsen egyetlen olyan
elem se, amely meghibásodása esetén az egész rendszer leállna. Egy
egyszerû példa: az idõs ember elhagyja az ágyát, majd a lakását is, és
megadott idõn belül nem tér vissza. Két szenzor is jelez a türelmi idõ
letelte után. A rendszer lehetõséget ad arra, hogy egy szenzor több
központnak is jelezzen, valamint azt, is, hogy egy központban ugyanarról
a jelzésrõl többen is értesítést kapjanak. Természetesen a redundanciát
tovább is fokozhatjuk, de ha ezt nem is tesszük, akkor is a következõkre
számíthatunk:

\begin{itemize}
\item Legrosszabb esetben is kieshet egy elem, és a rendszerünk
tökéletesen fog tovább üzemelni.
\item Két elem kiesésekor már fennáll a veszélye annak, hogy gond lesz,
például ha a két szenzor esik ki.
\item Legjobb esetben három elem is kieshet: ha pont az egyik szenzor,
az egyik központ és az egyik terminál esik ki.
\end{itemize}

A redundancián, mint az életviteli rendszerek szempontjából a leginkább
szembetûnõ elõnyön kívül azonban más pozitívumai is lehetnek egy
elosztott rendszernek. Említésre méltó, hogy a terminálok akár
leválasztott (hálózati kapcsolat nélküli) állapotban is hozzáférnek a
korábban megkapott üzenetekhez, valamint ha ezek között keresni akarnak
az szintén gyorsabb lesz, mint egy központosított rendszer esetén,
hiszen nem kell hálózati késleltetéssel számolni.

\subsubsection{A rendszer elemei}

\paragraph*{Csomópontok}

Ebbõl következõen a rendszer \emph{csomópontokból} épül fel. A
csomópontoknak két fontosabb fajtáját különböztetjük meg: a
\emph{központokat} és a \emph{végpontokat}.

\paragraph*{Központok}

Egy központ bekapcsolás után nem tesz semmit, csak vár arra, hogy
végpontok keressék. Ha egy végpont központot keres, akkor válaszol. Ha
egy végpont regisztrál, akkor nevet ad neki, és erre a névre más
végpontok feliratkozhatnak. Ilyen módon a végpont úgy küldhet üzenetet,
hogy nem tudja, hogy pontosan ki fogja megkapni. Ténylegesen csak a
központnak küldi el, majd a központ küldi tovább a feliratkozott
végpontoknak.

A központ nem rejti el az eredeti feladót, az üzenetet kapott végpontnak
lehetõsége van válaszolni az eredeti feladónak, abban az esetben ha
például döntés szükséges. Ebben az esetben az üzenet közvetlenül kerül
átvitelre a két végpont között, központok igénybevétele nélkül.

A központ ezenkívül hajlandó kiadni egy név mögött álló szenzor címét
is, ez akkor hasznos, hogyha a végpont tudja a számára érdekes szenzor
nevét, de az aktuális címét nem, valamint a szenzor sose ad ki magáról
adatot implicit módon, így más módon a végpont nem szerezhetne tudomást
a szenzor címérõl.

\paragraph*{Végpontok}
A végpontok bekapcsolás után szórt üzenetet küldenek, majd várnak, amíg
legalább egy központ válaszol a kérésre.

\paragraph*{Szenzorok}
A végpontoknak két fajtáját különböztetjük meg. Ezek egymástól sokkal
inkább logikailag, mintsem technikailag különböznek. A \emph{szenzorok}
olyan érzékelõk, melyek a környezetrõl szolgáltatnak információt. Ez az
információ-adás lehet implicit vagy explicit. Implicit eset alatt azt
értjük, ha például egy hõmérõ a mért hõmérsékletet óránként elküldi az
általa ismert központoknak. Explicit esetben viszont egy másik végpont
kérésére, közvetlenül a másik végpontnak bármikor elküldheti a kért
adatot. Láthatjuk, hogy az implicit esetet nem elõzi meg kérés-üzenet,
míg explicit esetben mindig csak egy végpont kap értesítést.

Egy érdekes probléma annak a jelenségnek a kezelése, mely olyan
szenzorok integrálásakor merül fel, melyek folyamatosan mérnek. Ezeket
tehát nem lehet explicit módon lekérdezni, viszont az összes mért adat
implicit közlése indokolatlanul nagy hálóhati forgalmat generálna. Ezt a
problémát úgy küszöbölhetjük ki -- ezáltal ezt a szenzor-típust
beillesztve a fenti két szenzor-kategóriába --, hogy a mûszer elé
teszünk egy modult, mely mindig tárolja az utoljára mért értéket. Így a
legutóbbi mért adat explicit módon bárkinek bármilyen idõpontban
elérhetõvé válik.

Egy másik tulajdonság, melyben a szenszorok különbözhetnek a
vezérelhetõség.

Például egy hõmérõ esetében a legtöbbször nincs mit vezérelni, ellenben
egy ház ajtajába szerelt zár esetén megoldható, hogy ne csak lekérdezni
tudjuk, hanem a zár állapotát vezérelni is lehessen.

\paragraph{Terminálok}
A \emph{terminálok} olyan végpontok, melyek elsõsorban üzenetek
fogadására hivatottak, tehát bekapcsolás után keresnek legalább egy
központot, valamint vagy elõre beállított, vagy a felhasználó által
interaktívan beállítható módon feliratkoznak a központ(ok)
névszolgáltatása által adott eseményekre. A terminálok között lehet
passzív, mint például egy képernyõ, vagy aktív, például egy
mobiltelefon. Az aktív terminálok reagálhatnak egy-egy üzenetre, míg a
passzívok csak tájékoztató üzeneteket képesek megjeleníteni.

Egy gyakorlati példa például, hogy a tûzjelzõ jelez a központnak, a
központ továbbítja az üzenetet egy telefonra, ott a célszemély egy
üzenetet küld a tûzjelzõt tartalmazó lakás ajtajában lévõ zárnak, hogy
az adja meg az állapotát, az válaszol közvetlenül a telefonra, hogy
zárva van, majd a célszemély úgy dönt, hogy ez az állapot nem kívánatos,
és egy olyan vezérlõ-üzenetet küld a zárnak, hogy az nyíljon ki. Ez a
folyamat akár meg is mentheti egy idõs ember életét, aki nem képes a
nagy füstben kinyitni az zárat, ellenben az egyszerûen kilinccsel
nyitható ajtón keresztül már képes elhagyni a lakást.

\subsubsection{Dinamizmus}

Volt már szó arról, hogy értelemszerûen minden csomópont futási idõben
képes változtatni azon csomópontok listáját, amelyekkel kommunikálni
képes. Központok esetén ez azt jelenti, hogy egy új szenzor
regisztrációjakor nem kell a rendszert újraindítani, a végpontok pedig
bármikor lekérhetik egy üzenetbõl az eredeti feladót, vagy egy központ
névszolgáltatásán keresztül egy, a név mögött álló szenzor címét, majd
annak üzenetet küldhetnek. Ezek az igények nélkülözhetetlenek a rendszer
mûködéséhez.

Amire viszont elsõ körben nem biztos, hogy gondolnánk, az az, hogy a
központoknak különbözõ típusú szenzorokat kell kezelniük, és ez
korántsem egyszerû feladat. A probléma az, hogy minden szenzor más módon
hajlandó adatokat szolgáltatni. Még ha feltételezzük, hogy minden
szenzor egy Erlang csomópont is, akkor is más üzenetet kell küldeni egy
hõmérõnek (például \texttt{getTermperature()}), és mást egy
vérnyomásmérõnek (például \texttt{getBloodPressure()}). Ezek egységes
kezeléséhez a központban driverek szükségesek.

A megoldás tehát az lesz, hogy minden szenzor-típus egy egyedi
azonosítóval rendelkezik, ezt elküldi a központnak, a központ az
azonosító alapján letölt egy drivert, betölti, és onnantól tudja, hogy
hogyan kell kezelni.

\subsubsection{Biztonság}

Az elõzõ alfejezet címe kapcsán a dinamizmus szóról még egy jelenség
juthat eszünkbe: amíg mûködik addig jó, de ha valami gond van a
rendszerrel, akkor bajban vagyunk, hiszen egy dimanikusan mûködõ
rendszerben hibát keresni nem kellemes feladat. Ha tovább keressük a
problémákat a dinamizmussal, akkor felmerül az a kérdés is, hogy milyen
biztonsági kockázatokat hozunk be ezzel a rendszerbe.

A két probléma részben összefügg, de valójában független. Az inteligens,
plug-and-play rendszerekre valós igény van idõs embereknél, hiszen õk
nem szakemberek, így nem várható el, hogy hosszabb tanulás elõzi meg a
rendszer használatát. Tekintve, hogy elsõsorban õértük jött létre a
rendszer, ezt nem hagyhatjuk figyelmen kívül. A másik cél -- a rendszer
üzemeltetõinek szemszögébõl -- természetesen, hogy minél inkább kontroll
alatt legyen a rendszer, kézzel állítva mindent, hogy a nem várt
eseményeket elkerüljük. Sajnos a két célt nem lehet kifogástalanul
teljesíteni egyszerre, de találhatunk olyan kompromisszumos megoldást,
mely mindkét fél türéshatárán belül helyezkedik el.

A biztonság kérdése annyiben kapcsolódik az elõzõ problémához, hogy egy
biztonságos rendszer egyik alapfeltétele, hogy minden, a rendszer
számára érdekes objektum azonosítva legyen, ami jelen esetben azt
jelentené, hogy a felhasználók és az eszközök is valamilyen
authentikációs mechanizmus teljesítése után válhassanak csak a rendszer
részévé. Ez problémát jelenthet például egy idõs embernél, aki
telefonálni se tud, mikor elesett, nem hogy jelszavakat megadni, mielõtt
értesítené a központot. Ezzel ellentétes igény, hogy ne helyezhessen el
bárki egy terminált az ablakunk alatt, mely azonnal értesíti a támadót,
ahogy elhagytuk a lakást.

Jelen munkában ezt a felmerülõ két problémát úgy oldjuk meg, hogy
feltételezzük a közvetkezõket:

\begin{itemize}
	\item A központoknak van interaktív felhasználói felülete.
	\item A központokhoz fizikailag csak olyan személy fér hozzá,
akinek van is jogosultsága ehhez.
	\item A rendszer minden végpontja egyedi azonosítóval
rendelkezik, melyet nem tud megváltoztatni.
	\item A kommunikációra használt csatorna biztonságos. (Vagy
titkosított, vagy zárt a hálózat.)
	\item A központokhoz ha új szenzor vagy terminál próbál
csatlakozni, akkor azt elsõ alkalommal ezt a központban jóvá kell
hagyni. Legalább az elsõ végpont jóváhagyását fizikailag a központban
kell elvégezni. (Innentõl az engedélyezett eszköz távolról is
engedélyezhet más eszközöket.)
\end{itemize}

Ezekkel a feltételekkel idõs emberek is könnyen integrálhatnak új,
gyárilag a rendszerrel kompatibilisnak tervezett eszközöket a
rendszerbe, anélkül, hogy potenciális biztonsági réseket hagynánk abban.

Összehasonlításképpen megemlítjük, hogy hasonló jellegû probléma merül
fel Bluetooth rendszerek esetén, egy ,,önlejátszó'' CD számítógépbe tétele
esetén, és még sok más példát lehetne hozni. A Bluetooth rendszer esetén
a megoldás az lett, hogy ha két eszköz kommunikálni akar, akkor azokat
egyszer párosítani kell, és ehhez a mechanizmushoz egy korábban
egyeztetett jelszót kell megadni. Ha mindkét oldalon ugyanazt a jelszót
adják meg, akkor a párosítás sikerült. Az CD-k esetében Windows
operációs rendszer esetén úgy döntöttek, hogy alapértelmezésben
figyelmeztetés nélkül elindul a program, amint behelyeztük a CD-t a
meghajtóba. Ezt természetesen tiltani lehet, és a biztonsági kérdésekre
kicsit komolyabban odafigyelõ felhasználók ezt meg is teszik.
Ellenpéldaként lehetne felhozni a legtöbb UNIX operációs rendszert, ahol
a CD automatikus csatolása vagy fel se merül problémaként, vagy a
felhasználóbarátabb rendszerekben is alapértelmezésként csak jelzést
kap a felhasználó a CD behelyezésérõl, de automatikus csatolásra
felhasználói interakció nélkül soha nem kerül sor.

\subsubsection{Határok}

A fõ követelmények áttekintésének végén megjegyezzük azt, amire már a bevezetõben is utaltunk: jelen munka célja egy életviteli rendszer köztes rétegének kidolgozása. Szándékosan nem foglalkozunk tehát a következõkkel:

\begin{itemize}
\item Skálázhatósági kérdésekkel. A rendszerben típusonként kis számú
elem található meg, kisebb finomítások szükségesek lehetnek ha a
rendszert típusonként nagyságrendekkel több elemmel használjuk, ezekre
nem térünk ki.
\item Felhasználói felülettel. Az egyszerûség kedvéért az összes
csomópont a standard kimenetre (stdout) írja az üzeneteit. Egy tényleges
rendszerben ezt célszerû valamilyen felhasználóbarátabb grafikus vagy
webes felületre cserélni.
\item Távoli karbantartás. A driverek automatikus letöltésén kívül egyéb
automatikus kód-letöltéssel nem foglalkozunk, de megjegyezzük, hogy a
driver-letöltéshez hasonló módon az egyes csomópontok teljes szoftverét
frissíthetõvé lehetne tenni. Az Erlang rendszer használata esetén --
ahol futás közben lehet modulokat betölteni vagy frissíteni -- ehhez
nincs is szükség komolyabb erõfeszítésekre.
\end{itemize}

\subsection{Erlang és UML}

A rendszer tervezésekor formális jelölésrendszerként az UML (Unified
Modeling Language) jelöléseit használjuk. Az UML elõsorban
objektumorientált környezetbe készült, mig Joe Armstrong\cite{armstrong}
szerint az Erlang valójában nem objektumorientált nyelv, így a
jelölésrendszer nem használható magyarázat nélkül.

Anélkül, hogy általános megfeleltetést állítanánk fel az
objektumorientált nyelvek fogalmai és az Erlang rendszerben elérhetõ
elemek között, a jelen életviteli rendszer tervezése során a
következõket feltételezzük:

\begin{itemize}
\item Az objektumok az Erlang rendszerben Erlang processek lesznek.
\item Ha egy Erlang process üzenetet kap, és az üzenet típusa szerint az
üzenetre más-más módon reagál azt megfeleltethetjük az objektumok
metódusainak.
\item Szekvenciadiagramok esetén objektumok létrehozása alatt
\texttt{spawn()} hívásokat értünk, metódushívás alatt pedig adott típusú
üzenet küldését.
\item Állapotdiagramok esetén az egyes Erlang processek életciklusát
értjük, hiszen az Erlangban nincsenek tényleges változók, hacsak nem
számolunk egy külsõ adatbázissal.
\end{itemize}

A következõ alfejezetekben tehát az elõzõ alfejezetben kifejtett fõ
szompontokat pontosítjuk, az UML jelöléseit használva.

\subsection{Az elemek katalógusa}

A rendszer tehát a következõ elemekbõl fog állni:

\begin{itemize}
\item Node: a rendszerben lévõ bármilyen csomópont
\item Center: olyan csomópont, mely központ
\item Endpoint: olyan csomópont, mely végpont
\item Sensor: olyan végpont, mely elsõsorban üzeneteket küld
\item Terminal: olyan végpont, mely elõsorban üzeneteket fogad
\item Message: a csomópontok közötti üzenetek formátumát definiálja
\item Driver: a letölthetõ eszközmeghajtók interfészét definiálja
\end{itemize}

\subsection{Az elemek leírása}

\subsubsection*{Node}

\begin{itemize}
\item Leírás:

Egy Erlang processt jelöl, mely egyedi, nem megváltoztatható
azonosítóval rendelkezik.

\item Változók:

Id -- Egyedi azonosító, mely nem változtatható meg.

\item Szolgáltatások:

ping() -- Egy pong atommal válaszol, jelezve, hogy a process fut.
\end{itemize}

\subsubsection*{Center}

\begin{itemize}
\item Leírás:

Olyan Node-ot jelöl, melybe regisztrálhatnak szenzorok
valamint a regisztrált nevekre feliratkozhatnak terminálok. Csak
továbbítja az üzeneteket, nem tényleges feladó vagy címzett.

\item Változók:

Sensors -- Regisztált szenzorok név-cím párjait tartalmazó lista

Subscriptions -- Nevekre feliratkozott terminálok név-cím párjait
tartalmazó lista

\item Szolgáltatások:

start() -- Center indítása

stop() -- Center leállítása

reg(Address, Name) -- Sensor címének regisztrálása névként

subscribe(Name, Address) -- Névre feliratkozás egy Terminal adott címével

lookup(Name) -- Sensor nevének feloldása címre

notify(Message) -- Message feladása továbbítás céljából
\end{itemize}

\subsubsection*{Endpoint}

\begin{itemize}
\item Leírás:

Olyan Node-ot jelöl, mely csak küld vagy fogad üzeneteket, nem továbbít.

\item Változók:

Messages -- Beérkezett üzenetek listája.

\item Szolgáltatások:

Nincsenek.
\end{itemize}

\subsubsection*{Sensor}

\begin{itemize}
\item Leírás:

Olyan végpontot jelöl, mely a külvilág valamely változásának hatására
üzenetet küld. Támogathat még vezérlést, illetve explicit lekérdezést
is.

\item Változók:

Centers -- Azon központok listája, melyeket értesíteni kell ha változott
a környezet.

\item Szolgáltatások:

start() -- Sensor indítása

stop() -- Sensor leállítása

query(Message) -- Lekérdez egy adott funkciót, és a feladó címére
megküldi.

control(Message) -- Beállít egy adott funkciót.
\end{itemize}

\subsubsection*{Terminal}

\begin{itemize}
\item Leírás:

Olyan végpontot jelöl, mely elsõsorban üzenetek fogadására hivatott.
Opcionálisan üzeneteket is lehet vele küldeni, válaszként egy korábban
egy szenzortól kapott üzenetre.

\item Változók:

Nincsenek.

\item Szolgáltatások:

start() -- Terminal indítása

stop() -- Terminal leállítása

notify(Message) -- Üzenet átadása a terminál számára
\end{itemize}

\subsubsection*{Message}

\begin{itemize}
\item Leírás:

Egy Erlang ennest jelöl, mely egy adat mellett tartalmazza azt, hogy
az adat micsoda, kitõl jött, kinek megy és ki továbbította.

\item Változók:

data -- Egy szám, a mért érték vagy döntés.

description -- Ha a szenzor több típusú értéket is mérne, ez mondja meg,
hogy melyik típust jelöli az adat mezõ.

from -- A feladót jelöli.

to -- A címzettet jelöli.

receiver -- A központot jelöli.
\item Szolgáltatások:

Nincsenek.
\end{itemize}

\subsubsection*{Driver}

\begin{itemize}
\item Leírás:

Egy Erlang függvényt ír le, ezáltal lehetõvé téve, hogy különbözõ
szenzorokat egységes interfészen kezeljünk. A drivernek megküldjük, hogy
melyik Node hányadik funkcióját akarjuk lekérdezni/vezérelni, majd az
megmondja a funkció nevét, amit már az eszköz megért.

Például a \texttt{translate(sensor0@clevo.local, 0)} hatására az adott
driver válasza lehet az \texttt{sugar}, mely egy vérnyomás- és
vércukormérõ esetén a vércukor lekérdezését teszi lehetõvé.

\item Változók:

Nincsenek.
\item Szolgáltatások:

translate(Node, Number) -- Megad egy atomot, melyet metódusnévként
használhatunk ha a szenzort explicit módon akarjuk lekérdezni.
\end{itemize}

\subsection{Statikus struktúra diagram}

%A statikus struktúra diagram \aref{fig:statikus-struktura-diagram}.
%ábrán a rendszer elemeirõl tárolt adatokat, azok összefüggéseit és
%kapcsolatait mutatja.

\begin{figure}[H]
\centering
\includegraphics[width=150mm,keepaspectratio]{statikus-struktura-diagram.eps}
\caption{A rendszer statikus struktúra diagramja}\label{fig:statikus-struktura-diagram}
\end{figure}

A statikus struktúra diagram a rendszer elemeirõl tárolt adatokat, azok
összefüggéseit és kapcsolatait mutatja.

\subsection{Szekvencia diagramok}

\subsubsection*{Központ indulása}

\begin{figure}[H]
\centering
\includegraphics[width=50mm,keepaspectratio]{kozpont-indulasa.eps}
\caption{Szekvencia diagram: központ indulása}\label{fig:kozpont-indulasa}
\end{figure}

Az ábrán látható, hogy a központot mindig a felhasználó helyezi üzembe,
és a központ bekapcsolás után belép a várakozási hurokba.

Ebbõl a helyzetbõl aztán majd késõbb a regisztráló vagy riasztó
szenzorok és feliratkozó terminálok mozdíthatják ki.

\subsubsection*{Szenzor regisztrációja}

\begin{figure}[H]
\centering
\includegraphics[width=75mm,keepaspectratio]{szenzor-regisztracioja.eps}
\caption{Szekvencia diagram: szenzor regisztrációja}\label{fig:szenzor-regisztracioja}
\end{figure}

Az ábra mutatja, hogy a szenzor bekapcsolásakor már legalább egy
központnak bekapcsolt állapotban kell lenni a rendszerben. Ekkor a
szenzor regisztrál, majd a központ elküldi a címét, melyre a szenzor
jelezhet ha az szükséges.

\subsubsection*{Terminál regisztrációja}

\begin{figure}[H]
\centering
\includegraphics[width=75mm,keepaspectratio]{terminal-regisztracioja.eps}
\caption{Szekvencia diagram: terminál regisztrációja}\label{fig:terminal-regisztracioja}
\end{figure}

A terminál regisztrációja esetén is elõkövetelmény legalább egy központ
mûködése, ahova feliratkozhat a terminál, de itt a központnak nem kell
azonosítót küldenie, hiszen a terminál nem fogja értesíteni a központot
eseményekrõl.

\subsubsection*{Üzenetküldés szenzorról}

\begin{figure}[H]
\centering
\includegraphics[width=100mm,keepaspectratio]{uzenetkuldes-szenzorrol.eps}
\caption{Szekvencia diagram: üzenetküldés szenzorról}\label{fig:uzenetkuldes-szenzorrol}
\end{figure}

Az ábra azt mutatja, hogy az üzenetküldés akkor értelmes, ha egy központ
bekapcsolása és a szenzor regisztrációja után legalább egy terminál
feliratkozott az üzenetekre az üzenetküldés elõtt. Ilyenkor a szenzor a
központot értesíti, a központ pedig a terminált.

\subsubsection*{Üzenetküldés szenzorról, redundáns eset}

\begin{figure}[H]
\centering
\includegraphics[width=120mm,keepaspectratio]{uzenetkuldes-szenzorrol-redundans-eset.eps}
\caption{Szekvencia diagram: üzenetküldés szenzorról redundáns esetben}\label{fig:uzenetkuldes-szenzorrol-redundans-eset}
\end{figure}

Az elõzõ eset általánosítása ha több szenzort, központot és terminált
helyezünk el a rendszerben. Az ábra két-két példány kommunikációját
mutatja be abban az esetben ha olyan esemény következik be, melynek
hatására mindkét szenzor jelez.

\subsubsection*{Explicit lekérdezés terminálról}

\begin{figure}[H]
\centering
\includegraphics[width=100mm,keepaspectratio]{explicit-lekerdezes-terminalrol.eps}
\caption{Szekvencia diagram: explicit lekérdezés terminálról}\label{fig:explicit-lekerdezes-terminalrol}
\end{figure}

Explicit lekérdezés esetén a terminál elõször a központhoz fordul a
szenzor címéért, majd a címnek birtokában közvetlenül a szenzornak küld
üzenetet az adatok lekérdeze céljából.

\subsubsection*{Eszköz engedélyezése}

\begin{figure}[H]
\centering
\includegraphics[width=100mm,keepaspectratio]{eszkoz-engedelyezese.eps}
\caption{Szekvencia diagram: eszköz engedélyezése}\label{fig:eszkoz-engedelyezese}
\end{figure}

Az eszközök engedélyezése esetén az ábrán látható módon elsõ alkalommal
ha egy szenzor regisztrálni vagy egy terminál feliratkozni akar, akkor a
felhasználónak azt egyszer engedélyeznie kell.

\section{Megvalósítás}

A megvalósítás során a tervezés folyamán felmerült használati eseteket
fogjuk sorra implementálni. Terjedelmi okokból nem kerül megvalósításra
a teljes funkcionalitás, így célszerû mindjárt az elején definiálni,
hogy mely részletek esetén alkalmazunk egyszerûsítéseket, és hol cél a
teljes megvalósítás.

A tervezés során definiált osztályok, az párhuzamosság, hibatûrés és
elosztottság támogatása a program részét képezik. Az elkészítés során
nyomon fogjuk követni, ahogy a tervezés szakaszában leírt használati
esetek sorra mûködõképessé válnak.

Ami nem kerül teljes megvalósításra:

\begin{itemize}
\item A szenzorok nem automatikusan fedezik fel a központokat, hanem egy
konfigurációs állomány elõre definiálja ezek listáját.
\item A korábban felvetett biztonsági kérdésekkel nem foglalkozunk,
feltételezzük, hogy a rendszer zárt, a rendszer elemei pedig
megbízhatóak.
\item Eltekintünk a grafikus felhasználói felület létrehozásától,
egyszerû parancssoros interfészt biztosítva a felhasználó számára.
\end{itemize}

\subsection{Elsõ, már mûködõ változat}

A legkisebb már mûködõ változata a rendszernek az az eset, mikor a
rendszerben egy szenzor, egy központ és egy terminál van. Mivel ez lesz
minden késõbbi változat alapja, tekintsük át tüzetesen a mûködését. A
késõbbiekben csak az ehhez a változathoz képest eszközölt módosítások
kerülnek ismertetésre.

E változat mûködése során a felhasználó egy központot indít, majd egy
terminált, mely regisztrál a központba, végül egy szenzort, mely indulás
után azonnal értesít. Ezt az értesítést kapja meg a központ, majd
továbbítja a terminálnak.

\subsubsection*{Központ}

A központ három olyan függvényt definiál, mely a process életciklusát
érinti:

\begin{lstlisting}
start() -> register(center, spawn(fun() -> put(sensors, []), put(subscriptions, []), loop() end)).

stop() -> center ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

A start/0 függvény egy új processt indít az aktuális node-on, mely
inicializálja a szenzorok és feliratkozások listáját, majd várakozó
állapotba kerül, ld. késõbb.

A stop/0 függvény ennek az új processnek küld egy üzenetet, melynek hatására az leáll.

A ping/0 függvény kizárólag hibakeresési célokat szolgál a lejjebb
ismertetésre kerülõ rpc/1 függvény felhasználásával, lehetõvé téve, hogy
megvizsgáljuk, hogy a központ válaszképes-e.

További négy függvény pedig a központ tényleges vezérlésére szolgál:

\begin{lstlisting}
reg(Address, Name) -> rpc({reg, Address, Name}).

lookup(Name) -> rpc({lookup, Name}).

subscribe(Name, Address) -> rpc({subscribe, Name, Address}).

notify(Message) -> rpc({notify, Message}).
\end{lstlisting}

Láthatjuk, hogy ezek mind a lenn ismertetett rpc/1 függvény köré épített
csomagoló függvények.

A csomagoló függvények által hívott rpc/1 függvény a következõ:

\begin{lstlisting}
rpc(Q) ->
 center ! {self(), Q},
 receive
  {center, Reply} ->
   Reply
 end.
\end{lstlisting}

A függvény a korábban center néven regisztrált
\footnote{Regisztráció és regisztráció törlése alatt itt az Erlang
rendszer register/2 és unregister/1 függvényeit értjük, mely lehetõséget
biztosít arra, hogy az aktuális node-on Pid-ekhez atomokat rendeljünk.
Ezek a regisztrációk más node-okról nem láthatóak, a teljes rendszer
szintjén nem egyediek, és ezt ki is fogjuk használni.}
processnek küld egy két
elemû ennest, megküldve a saját címét, valamint a tényleges adatokat,
majd a válaszként kapott értékkel tér vissza.

Végül a center néven regisztrált processünk fõ függvénye a következõ:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {center, pong},
   loop();
  {From, {reg, Address, Name}} ->
   io:format("[~p] reg(~p,~p)~n", [node(), Address, Name]),
   Sensors = get(sensors),
   put(sensors, [{Address, Name}| Sensors]),
   From ! {center, ok},
   loop();
  {From, {lookup, Name}} ->
   io:format("[~p] lookup(~p)~n", [node(), Name]),
   Sensors = get(sensors),
   A = [A || {A, N} <- Sensors, N =:= Name],
   From ! {center, {ok,A}},
   loop();
  {From, {subscribe, Name, Address}} ->
   io:format("[~p] subscribe(~p,~p)~n", [node(), Name, Address]),
   Subscriptions = get(subscriptions),
   put(subscriptions, [{Name, Address}| Subscriptions]),
   From ! {center, ok},
   loop();
  {From, {notify, Message}} ->
   io:format("[~p] notify(~p)~n", [node(), Message]),
   {Data, Description, Fro, To, _Receiver} = Message,
   lists:foreach(fun(I) -> rpc:call(I, terminal, notify, [{Data, Description, Fro, To, node()}]) end,
    [A || {N, A} <- get(subscriptions), N =:= To]),
   From ! {center, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

Az egyes beérkezõ üzenetekre tehát a következõ válaszokat adja:

\begin{itemize}
\item A ping atomra mindig pong atommal válaszol.
\item A reg atomra a paraméterként kapott szenzor címét és nevét
regisztrálja a egy listába, melyet a process dictionary-ben tárol, így
késõbb is lehetõvé válik annak módosítása.
\item A lookup atomra a paraméterként kapott névhez tartozó szenzor
címet adja vissza vissza a sensors listából.
\item A subscribe atomra a paraméterként kapott névhez eltárolja a kapott címet.
\item A notify atom esetén egy öt elemû ennest (melynek elemeit a
tervezés során Message néven definiáltuk) vár paraméterként. Ebben
szerepel az, hogy milyen névre szól az üzenet. A központ azoknak a
termináloknak továbbítja az üzenetet, amelyek ilyen névvel iratkoztak
fel, beleírva saját magát, mint továbbító.
\item Végül a stop atomra leállítja az aktuális Erlang node-ot.
\end{itemize}

A másik két elemmel ellentétben itt megfigyelhetõ, hogy a központnak
nincs konfigurációs állománya, valamint elindítása után nincs semmilyen
bekövetkezõ esemény.

\subsubsection*{Terminál}

A struktúra diagramban láthattuk, hogy a Center és a Terminal is egy
Node, így itt is megtalálható a három, a process életciklusával
kapcsolatos függvény:

\begin{lstlisting}
start(ConfigFile) ->
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) -> rpc:call(C, center, subscribe, [E, node()]) end, Centers),
 register(terminal, spawn(fun() -> loop() end)).

stop() -> terminal ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

A start/1 függvény azonban itt egy konfigurációs állományt vár paraméterül. Erre egy példa:

\begin{lstlisting}
{center, center0@clevo.local, event}.
\end{lstlisting}

A konfigurációs állomány szintaxisára az egyetlen megkötés az, hogy
minden egyes sorban egy Erlang termnek kell lennie, mivel ezt fogadja el
a file:consult/1 értelmezõ függvény. A fenti fájlban az egyetlen sor egy
központra való feliratkozást definiál, erre utal a center atom. Az ennes
másik két paramétere a központ címét
\footnote{
A következõ, tesztelésrõl is szóló fejezetben látni fogjuk, hogy mi az
oka annak, hogy a cím ebben a formátumban lett megadva. Általánosságban
a cím egy node-ot és egy gépet azonosító atomból áll, a kukac
karakterrel összekötve.
}
és annak az eseménynek a nevét
definiálja, melyre fel szeretnénk iratkozni az adott központban.

Az indítás során tehát értelmezzük a beállításokat, és a kérésnek
megfelelõen feliratkozunk a központoknál, azok subscribe metódusát
meghívva. Ha ez megtörtént, üzenetre várunk a lenn ismertetésre kerülõ
loop/0 függvény használatával.

A stop/0 és ping/0 feladata és mûködése más ismerõs, a center modulban
definiáltakkal megegyezõ.

A terminálnak egyetlen, a modellben is létezõ metódusa a notify/1:

\begin{lstlisting}
notify(Message) -> rpc({notify, Message}).
\end{lstlisting}

A center:notify/1-hez hasonló módon ez is csak csomagoló függvény az
rpc/1 köré.

A terminal modul maradék része a korábban hivatkozott rpc/1 és loop/0
függvényekbõl áll:

\begin{lstlisting}
rpc(Q) ->
 terminal ! {self(), Q},
 receive
  {terminal, Reply} ->
   Reply
 end.

loop() ->
 receive
  {From, {ping}} ->
   From ! {terminal, pong},
   loop();
  {From, {notify, Message}} ->
   io:format("[~p] notify(~p)~n", [node(), Message]),
   From ! {terminal, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

Az rpc/1 feladata tehát kommunikálni a terminal néven regisztrált
process-szel: az üzenetküldés után válaszra várni, majd azzal
visszatérni. A center modulhoz hasonló módon itt is azért van erre
szükség erre a csomagolásra, mivel terminal néven más node-on más
processt érhetünk el.

A loop/0 függvény pedig üzeneteket vár:

\begin{itemize}
\item A ping és stop atomok az életciklus monitorozására és vezérlésére
szolgálnak a center modullal megegyezõ módon.
\item A notify atomra pedig a terminál egyszerûen a standard kimenetre
küldi a kapott üzenet tartalmát, nem túl felhasználóbarát módon.
\end{itemize}

\subsubsection*{Szenzor}

A sensor modul implementációja a start, stop és ping metódusokra:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E]),
  Message = {Data, desc, node(), E, false},
  rpc:call(C, center, notify, [Message])
 end, Centers),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)).

stop() -> sensor ! stop.

ping() -> rpc({ping}).
\end{lstlisting}

Láthatjuk, hogy a start függvény itt is használ egy konfigurációs
állományt, melynek azonos a formátuma a szenzoréval. A feladata
természetesen más: itt azt adja meg, hogy melyik központnak milyen néven
kell elküldeni a mérési adatainkat.

Az elsõ változat tehát rögtön indulás után küld egy üzenetet a
konfigurációs állományban megadott központba, a megadott eseménynevet
használva, mely arról fogja informálni a terminálokat, hogy a desc
típusú mérési adat értéke data.

A tervezés során a szenzorok explicit lekérdezésének igénye is
felmerült, az ehhez szükséges függvények:

\begin{lstlisting}
query_data(Message) -> rpc({query_data, Message}).

control(Message) -> rpc({control, Message}).

rpc(Q) ->
 sensor ! {self(), Q},
 receive
  {sensor, Reply} ->
   Reply
 end.
\end{lstlisting}

Az elõzõekben megszokott módon ezek is az rpc/1 függvényt hívják,
melynek mûködési elve nem változott a korábbi két modulhoz képest.

A korábban hivatkozott loop/0 függvénye pedig a következõ:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {sensor, pong},
   loop();
  {From, {query_data, {_Data, _Desc, Fro, _To, _Recv}}} ->
   rpc:call(Fro, terminal, notify, [{get(desc), desc, node(), Fro, false}]),
   From ! {sensor, ok},
   loop();
  {From, {control, {Data, _Desc, _Fro, _To, _Recv}}} ->
   put(desc, Data),
   From ! {sensor, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

\begin{itemize}
\item A ping és stop atomok kezelését már ismerjük
\item A query\_data atom hatására a szenzor process dictionary-jébõl lehet lekérdezni.
\item A control atom segítségével pedig vezérelni lehet a szenzort.
\end{itemize}

\subsection{Redundáns mûködés}

A redundáns mûködés két szempontból különbözik az elõzõ alfejezetben
ismertetett változathoz képest:

\begin{itemize}
\item A rendszer indításakor mindhárom elembõl két példányt kell indítani.
\item A terminálok és szenzorok konfigurációs állományába két-ket
központot kell definiálni.
\end{itemize}

Ez utóbbit például a következõképpen tehetjük meg:

\begin{lstlisting}
{center, center0@clevo.local, event}.
{center, center1@clevo.local, event}.
\end{lstlisting}

\subsection{Meghajtóprogramok támogatása}

Meghajtóprogramokra akkor van szükségünk, ha egy általános interfészen
keresztül akarunk elérni egy-egy eszközt, melynek a speciális jellemzõit
nem ismerjük. Tegyük fel, hogy egy szenzor több mérést is képes végezni,
és ezeket számozzuk.  A megvalósított példa esetén a szenzor egy
querydesc/0 függvénnyel rendelkezik, a terminál ezt szeretné explicit
módon lekérdezni, de csak annyit tud, hogy ez a nulladik típusú mérési
funkciója az eszköznek. A driver modul fog abban segíteni, hogy a 0
alapján megkapja a querydesc atomot.

A modul egyetlen translate/2 függvényt definiál az interfészében:

\begin{lstlisting}
sub(Str,Old,New) ->
       RegExp = "\\Q"++Old++"\\E",
       re:replace(Str,RegExp,New,[multiline, {return, list}]).

translate(Node, Num) ->
       Module = sub(sub(atom_to_list(Node), "@", "_"), ".", "_"),
       compile:file(Module),
       Modulea = list_to_atom(Module),
       list_to_atom(Modulea:translate(Num)).
\end{lstlisting}

Az elsõ segédfüggvény node nevébõl a driver modul nevét állítja elõ, A
kukacokat és pontokat aláhúzásjellel helyettesítve. A második pedig az
elõállított modulnév alapján lefordítja a drivert, meghívja annak
translate metódusát, és a kapott értékkel visszatér.

A sensor0\_clevo\_local modul egyetlen translate/1 függvényt definiál:

\begin{lstlisting}
translate(Num) ->
       case Num of
        0 ->
         "querydesc";
        _ ->
         false
       end.
\end{lstlisting}

Ahhoz, hogy ezt ki is próbálhassuk, a szenzor kódjában a querydesc
függvényt implementálni kell:

\begin{lstlisting}
querydesc() -> rpc({querydesc}).
\end{lstlisting}

Valamint a loop/0 függvényben egy új esetet kell felvenni:

\begin{lstlisting}
        {From, {querydesc}} ->
         From ! {sensor, get(desc)},
         loop();
\end{lstlisting}

\subsection{Felhasználói felület}

Idáig alapvetõen azzal foglalkoztunk, hogy hogyan tudunk adatokat küldeni Erlang node-ok között.

A felhasználói felület feladata, hogy az idáig elkészült middleware-t
felhasználva a felhasználók számára is hasznos támogatást nyújtson,
ezáltal tényleges életviteli rendszert megvalósítva.

Felhasználói felületünk kialakítását kezdjük a szenzorral. A start/1
függvény idáig visszatért ha sikeres volt az üzeneteket kezelõ process
regisztrációja terminal néven. Most ezt megváltoztatjuk, és
interaktívan, a standard bemenetrõl fogunk beolvasni értékeket, majd
azonnal jelzünk ha a felhasználó ENTER-t ütött.

Ehhez a szenzor kódjában a start/1 függvényt változtatjuk meg:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E])
 end, Centers),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)),
 io:format("Adja meg a mert adatot 'tipus szam' formaban, majd usson ENTER-t!\n"),
 io:format("A testhomerseklet merese utan peldaul 'h 38.2'\n"),
 read_stdin(Centers).
\end{lstlisting}

Az újonnan bevezetett read\_stdin függvény pedig:

\begin{lstlisting}
read_stdin(Centers) ->
 L = io:get_line("> "),
 [A|[B]] = re:split(L, " "),
 Desc = list_to_atom(binary_to_list(A)),
 {Data, _} = string:to_float(binary_to_list(B)),
 lists:foreach(fun({C, E}) ->
  Message = {Data, Desc, node(), E, false},
  rpc:call(C, center, notify, [Message])
 end, Centers),
 read_stdin(Centers).
\end{lstlisting}

A feladat második fele pedig a terminál átalakítása, azt szeretnénk,
hogyha a hõmérséklet értéke meghaladja 37.2 fokot, akkor csipogjon.
Egyéb esetben pedig egyszerûen adjon barátságos kimenetet.

Ehhez a terminal modul loop/0 függvényét a következõképpen módosítjuk:

\begin{lstlisting}
loop() ->
 receive
  {From, {ping}} ->
   From ! {terminal, pong},
   loop();
  {From, {notify, Message}} ->
   {Data, Desc, _Fro, _To, _Recv} = Message,
   case Desc of
    h ->
     case Data > 37.2 of
      true ->
       io:fwrite([7]),
       io:format("Figyelem, a homerseklet ~p homerseklet tobb a megengedettnel!~n", [Data]);
      _ ->
       io:format("Uj homerseklet adat: ~p.~n", [Data])
      end;
    _ ->
     io:format("A '~p' uj erteke: ~p.~n", [Desc, Data])
   end,
   From ! {terminal, ok},
   loop();
  stop ->
   init:stop()
 end.
\end{lstlisting}

\subsection{Hibatûrés}

A rendszerrel szemben elvárás, hogy hibatûrõ legyen, azonban ezt idáig
nem valósítottuk meg, például ha hõmérsékletnek nem lebegõpontos számot
adunk meg, akkor nem kapunk semmilyen hibát, egyszerûen hibás lesz a
mûködés.

Két feladatunk van tehát:

\begin{itemize}
\item A hiba esetén biztosítani, hogy leálljon az adott process, mielõtt
az hibás mûködéshez vezetne.
\item A leállt process helyébe újat indítani.
\end{itemize}

A leállás biztosításához a terminal:read\_stdin/0 függvényt a következõképpen
módosíthatjuk:

\begin{lstlisting}
read_stdin(Centers) ->
 L = io:get_line("> "),
 [A|[B]] = re:split(L, " "),
 Desc = list_to_atom(binary_to_list(A)),
 {Data, _} = string:to_float(binary_to_list(B)),
 case Data of
  error ->
   erlang:error(badarg);
  _ ->
   lists:foreach(fun({C, E}) ->
      Message = {Data, Desc, node(), E, false},
      rpc:call(C, center, notify, [Message])
    end, Centers),
   read_stdin(Centers)
 end.
\end{lstlisting}

Az új process indítása két lépéses folyamat. Elõször is definiálni kell
egy függvényt, mely akkor hívódik meg, ha az aktuális process leáll:

\begin{lstlisting}
on_exit(Pid, Fun) ->
 spawn(fun() ->
  process_flag(trap_exit, true),
  link(Pid),
  receive
   {'EXIT', Pid, _Why} ->
    Fun()
  end
 end).
\end{lstlisting}

Valamint a start/1 függvényben ezt a függvényt regisztrálnunk kell:

\begin{lstlisting}
start(ConfigFile) ->
 Data = data,
 {ok, Config} = file:consult(ConfigFile),
 Centers = [ {C, E} || {center, C, E} <- Config],
 lists:foreach(fun({C, E}) ->
  rpc:call(C, center, reg, [node(), E])
 end, Centers),
 catch unregister(sensor),
 register(sensor, spawn(fun() -> put(desc, Data), loop() end)),
 on_exit(self(),
  fun() ->
    io:format("A szenzor hibaval lepett ki, ujrainditas...~n"),
    start(ConfigFile)
  end),
 io:format("Adja meg a mert adatot 'tipus szam' formaban, majd usson ENTER-t!\n"),
 io:format("A testhomerseklet merese utan peldaul 'h 38.2'\n"),
 read_stdin(Centers).
\end{lstlisting}

\section{Eredmények, jövõbeli munka}

Ide jön majd többek között a (teszt)környezet leírása, erlang node-ok
indításának commandline paraméterei, viaskodás a tûzfallal, tehát minden
ami a kódon kívül szükséges információ ahhoz, hogy valaki kipróbálhassa
a munkámat.

\bibliography{szakdolgozat}
\bibliographystyle{unsrt}
\addcontentsline{toc}{section}{Hivatkozások}

\end{document}
